====== DIRECTORY TREE ======
./
    .gitignore
    all-lines.txt
    context.py
    LICENSE
    preview_0.gif
    preview_1.gif
    preview_2.gif
    preview_3.gif
    preview_4.gif
    README.md
    burger/
        index.html
        package-lock.json
        package.json
        vite.config.js
        public/
            static/
                bun1.glb
                bun2.glb
                cheese.glb
                lettuce.glb
                meat.glb
                onion.glb
                tomato.glb
                ui_arrow.png
                ui_main-.png
                ui_main.png
                ui_switch0_OFF.png
                ui_switch0_ON.png
                ui_switch1_OFF.png
                ui_switch1_ON.png
                ui_switch2_OFF.png
                ui_switch2_ON.png
                ui_switch3_OFF.png
                ui_switch3_ON.png
                ui_switch4_OFF.png
                ui_switch4_ON.png
                fonts/
                    helvetiker_bold.typeface.json
                    helvetiker_regular.typeface.json
                    roboto_black.typeface.json
        src/
            BurgerMaterials.js
            BurgerModels.js
            BurgerNames.js
            BurgerStack.js
            BurgerUI.js
            HandTracking.js
            Lights.js
            main.js
            style.css
            XRScene.js
    chair/
        index.html
        package-lock.json
        package.json
        vite.config.js
        public/
            static/
                2k.hdr
                chair.glb
                sizes.glb
                ui_button1.png
                ui_button2.png
                ui_button3.png
                ui_buttonstroke.png
                ui_colors.png
                ui_frame.png
                ui_header-toggle-switch.png
                ui_header-toggle.png
                ui_header.png
                ui_info.png
                ui_pull.png
                fonts/
                    helvetiker_regular.typeface.json
                shaders/
                    fresnel_fragment.glsl
                    fresnel_vertex.glsl
                    sizes_fragment.glsl
                    sizes_vertex.glsl
        src/
            ChairExperience.js
            HandInput.js
            main.js
            Shaders.js
            style.css
            UIPanels.js
            XRSetup.js
    glowcube/
        index.html
        package-lock.json
        package.json
        vite.config.js
        src/
            main.js
            style.css
            assets/
                shaders/
                    fragment.glsl
                    vertex.glsl
    sneaker/
        index.html
        package-lock.json
        package.json
        vite.config.js
        public/
            static/
                2k.hdr
                cloud.glb
                product.glb
                ui_button-done.png
                ui_button-search.png
                ui_circle.png
                ui_close.png
                ui_colorcircle.png
                ui_dotcircle.png
                ui_header-tags.png
                ui_header.png
                ui_selector.png
                ui_tag0-OFF.png
                ui_tag0-ON.png
                ui_tag1-OFF.png
                ui_tag1-ON.png
                ui_tag10-OFF.png
                ui_tag10-ON.png
                ui_tag11-OFF.png
                ui_tag11-ON.png
                ui_tag2-OFF.png
                ui_tag2-ON.png
                ui_tag3-OFF.png
                ui_tag3-ON.png
                ui_tag4-OFF.png
                ui_tag4-ON.png
                ui_tag5-OFF.png
                ui_tag5-ON.png
                ui_tag6-OFF.png
                ui_tag6-ON.png
                ui_tag7-OFF.png
                ui_tag7-ON.png
                ui_tag8-OFF.png
                ui_tag8-ON.png
                ui_tag9-OFF.png
                ui_tag9-ON.png
                fonts/
                    roboto_black.typeface.json
        src/
            Environment.js
            HandInput.js
            main.js
            Models.js
            style.css
            UIColorPicker.js
            UIHeader.js
            UITagsCloud.js
            XRSetup.js
    tictactoe/
        index.html
        package-lock.json
        package.json
        vite.config.js
        public/
            static/
                2k.hdr
                o.glb
                tictactoe.glb
                ui_button.png
                ui_wins.png
                x.glb
        src/
            BoardView.js
            EndGameUI.js
            GameState3D.js
            HandInput.js
            main.js
            style.css

====== CONTENT OF: .gitignore ======
/node_modules/
/dist/
/vite/
/.vercel/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
/.vscode/
/.idea/
.DS_Store
Thumbs.db
.env
.env.local
.env.development
.env.test
.env.production
/build/
*.log
*.tmp
.vercel

====== CONTENT OF: context.py ======
import os
import re
import argparse
import fnmatch
def get_directory_tree(path):
    tree = []
    default_excluded_dirs = ['.git', '.github', '.vscode', '__pycache__']
    for root, dirs, files in os.walk(path, topdown=True):
        dirs[:] = [d for d in dirs if d not in default_excluded_dirs]
        level = root.replace(path, '').count(os.sep)
        indent = ' ' * 4 * (level)
        tree.append(f'{indent}{os.path.basename(root)}/')
        sub_indent = ' ' * 4 * (level + 1)
        for f in files:
            tree.append(f'{sub_indent}{f}')
    return '\n'.join(tree)
def strip_comments(content, file_path):
    ext = os.path.splitext(file_path)[1].lower()
    if ext in ['.py']:
        content = re.sub(r'', '', content, flags=re.DOTALL)
        content = re.sub(r"", '', content, flags=re.DOTALL)
        content = re.sub(r'
    elif ext in ['.c', '.h', '.cpp', '.hpp', '.java', '.js', '.cs', '.go', '.ts', '.tsx']:
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        content = re.sub(r'//.*', '', content)
    elif ext in ['.html', '.xml']:
        content = re.sub(r'<!--.*?-->', '', content, flags=re.DOTALL)
    elif ext in ['.sh', '.bash', '.zsh', 'rb', 'yml', 'yaml']:
        content = re.sub(r'
    return content
def main():
    parser = argparse.ArgumentParser(description='Gather code files into a single file, excluding comments and specified files.')
    parser.add_argument('--exclude', nargs='*', default=[], help='A list of files or patterns to exclude.')
    args = parser.parse_args()
    current_directory = '.'
    output_file = 'all-lines.txt'
    default_excluded_extensions = ['.txt', '.pdf', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.mp4', '.mov', '.avi', '.mkv', '.zip', '.gz', '.tar', '.rar', '.exe', '.dll', '.so', '.a', '.lib', '.o', '.obj', '.class', '.pyc']
    default_excluded_dirs = ['.git', '.github', '.vscode', '__pycache__']
    user_excluded_files = args.exclude
    with open(output_file, 'w', encoding='utf-8') as outfile:
        outfile.write("====== DIRECTORY TREE ======\n")
        tree = get_directory_tree(current_directory)
        outfile.write(tree)
        outfile.write("\n\n")
        for root, dirs, files in os.walk(current_directory, topdown=True):
            dirs[:] = [d for d in dirs if d not in default_excluded_dirs and not any(fnmatch.fnmatch(d, pattern) for pattern in user_excluded_files)]
            for file in files:
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, current_directory)
                if any(file.lower().endswith(ext) for ext in default_excluded_extensions):
                    continue
                if any(fnmatch.fnmatch(file, pattern) for pattern in user_excluded_files):
                    continue
                if os.path.abspath(file_path) == os.path.abspath(output_file):
                    continue
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                        content = infile.read()
                    stripped_content = strip_comments(content, file)
                    lines = [line for line in stripped_content.splitlines() if line.strip()]
                    if lines:
                        outfile.write(f"====== CONTENT OF: {relative_path} ======\n")
                        outfile.write('\n'.join(lines))
                        outfile.write("\n\n")
                except Exception as e:
                    print(f"Could not process file {file_path}: {e}")
if __name__ == '__main__':
    main()

====== CONTENT OF: README.md ======
# webxr-ar-demos
A collection of Three.js-based WebXR demos optimized for AR glasses ([Spectacles](https://www.spectacles.com/)).
<br>
### Installation
Clone the repository:
```bash
git clone https://github.com/dmvrg/webxr-ar-demos.git
```
Then navigate to a demo folder and install dependencies to run it locally. For example:
```bash
cd webxr-ar-demos/glowcube
npm install
npm run dev
```
<br>
### Glow Cube
**Live demo:** https://webxr-glowcube.vercel.app/
Demo exploring real-time hand interaction and simple procedural effects in WebXR. By pinching with both hands, the user can spawn and scale a glowing cube with a GLSL shader, while a basic physics system (Cannon.js) handles motion and collisions.
The GLSL shader is based on [kishimisu’s video](https://www.youtube.com/watch?v=f4s1h2YETNY).
![Preview](preview_0.gif)
<br>
### Chair
**Live demo:** https://webxr-chair.vercel.app/
Demo where the user can explore a 3D chair model through hand gestures. By pressing buttons to change colors, and pinching and pulling the top-right switch, the model opens into space at 1:1 scale, allowing the user to inspect its dimensions and details.
**Code structure:**
- `main.js` — Initializes WebXR, scene, and render loop.
- `XRSetup.js` — Sets up Three.js renderer, camera, and XR session.
- `HandInput.js` — Tracks hand joints and pinch gestures for rotation and input.
- `ChairExperience.js` — Core logic for models, materials, animations, and interactions.
- `UIPanels.js` — Builds the floating UI: header toggle, color buttons, pull switch, info panel.
- `Shaders.js` — Loads and manages shaders.
![ preview](preview_1.gif)
<br>
### Burger
**Live demo:** https://webxr-burger.vercel.app/
Demo where the user can customize a 3D burger using hand interactions. With both hands, the burger can be opened into an exploded view, and individual ingredients can be toggled on and off.
**Code structure:**
- `main.js` — Initializes XR scene, loads models, and links UI, lighting, and hand tracking.
- `XRScene.js` — Sets up Three.js renderer, camera, and XR session.
- `BurgerMaterials.js` — Defines materials.
- `BurgerModels.js` — Loads and organizes model parts.
- `BurgerStack.js` — Builds model layers and manages open/joined states.
- `Lights.js` — Adds lighting and shadow fitting.
- `BurgerUI.js` — Creates in-world UI panels and switches.
- `HandTracking.js` — Handles pinch gestures and ingredient interactions.
![ preview](preview_2.gif)
<br>
### Sneaker
**Live demo:** https://webxr-sneaker.vercel.app/
Demo where the user can explore and customize a 3D product through direct hand interactions, using a color picker, size selector, 3D tag cloud, and a rotatable, draggable product model. Designed as a simple template and inspiration for future e-commerce AR UIs. The `product.glb` is a placeholder cube, which can be replaced with a product model (the `color` layer in the model defines which parts can have their color changed).
**Code structure:**
- `main.js` — Initializes XR scene, manages interactions, loads models, and orchestrates all UI modules.
- `XRSetup.js` — Configures Three.js renderer, camera, XR session.
- `HandInput.js` — Handles hand tracking, pinch gestures, and button touch detection.
- `UIHeader.js` — Builds the header bar and size UI.
- `UIColorPicker.js` — Manages the radial color selector and interaction.
- `UITagsCloud.js` — Creates and manages the 3D category tag cloud.
- `Environment.js` — Sets up lighting, reflections, and environment.
- `Models.js` — Loads and manages product and cloud models, toggling visibility and transitions.
![ preview](preview_3.gif)
<br>
### 3D Tic-Tac-Toe
**Live demo:** https://webxr-tictactoe.vercel.app/
Demo showing a 3D Tic-Tac-Toe game played through hand interactions against the computer. The player can rotate the floating 3×3×3 board by pinching and moving their hands, then place pieces using the same gesture. A simple heuristic AI evaluates all possible moves to win or block, while the system detects wins across any spatial line.
**Code structure:**
- `main.js` — Initializes WebXR and the scene, wires all systems together, runs the render loop, and orchestrates gameplay.
- `GameState3D.js` — Holds the 3×3×3 grid, checks wins/draws, and computes the AI’s next move.
- `BoardView.js` — Manages the 3D grid, sphere pick targets, O/X models, and the animated winning line.
- `EndGameUI.js` — Displays the win/lose message and reset button.
- `HandInput.js` — Tracks hand joints, detects pinches for placing pieces, handles board rotation, and detects button hits.
![ preview](preview_4.gif)

====== CONTENT OF: burger\index.html ======
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Burger Demo</title>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body>
    <canvas class ="webgl"> </canvas>
    <script type="module" src="./src/main.js"></script>
</body>
</html>

====== CONTENT OF: burger\vite.config.js ======
import glsl from 'vite-plugin-glsl'
export default {
    root: './',
    publicDir: './public/',
    base: './',
    server:
    {
        host: true, 
        open: !('SANDBOX_URL' in process.env || 'CODESANDBOX_HOST' in process.env) 
    },
    build:
    {
        outDir: './dist', 
        emptyOutDir: true, 
        sourcemap: true 
    },
    plugins:
    [
        glsl()
    ]
}

====== CONTENT OF: burger\src\BurgerMaterials.js ======
import * as THREE from 'three';
export function CreateBurgerMaterials() {
  const SHARED_STD = new THREE.MeshStandardMaterial({
    roughness: 0.5,
    metalness: 0.2,
    envMapIntensity: 1.0,
    side: THREE.FrontSide
  });
  function EnhanceModelMaterials(model) {
    model.traverse(c => {
      if (!c.isMesh) return;
      const m = c.material;
      if (m && m.side === THREE.DoubleSide) return;
      if (m && m.isMeshStandardMaterial) {
        m.roughness = 0.5;
        m.metalness = 0.2;
        m.envMapIntensity = 1.0;
        m.side = THREE.FrontSide;
      } else if (m && m.map) {
        const clone = SHARED_STD.clone();
        clone.map = m.map;
        c.material = clone;
      } else {
        c.material = SHARED_STD;
      }
      c.castShadow = c.receiveShadow = true;
    });
  }
  return { SHARED_STD, EnhanceModelMaterials };
}

====== CONTENT OF: burger\src\BurgerModels.js ======
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
const gltfLoader = new GLTFLoader();
function LoadModel(path) {
  return new Promise((resolve, reject) => {
    gltfLoader.load(path, gltf => resolve(gltf.scene), undefined, reject);
  });
}
export async function LoadBurgerModels(EnhanceModelMaterials) {
  const [bunTop, bunBottom, onion, meat, tomato, lettuce, cheese] = await Promise.all([
    LoadModel('/static/bun1.glb'),
    LoadModel('/static/bun2.glb'),
    LoadModel('/static/onion.glb'),
    LoadModel('/static/meat.glb'),
    LoadModel('/static/tomato.glb'),
    LoadModel('/static/lettuce.glb'),
    LoadModel('/static/cheese.glb')
  ]);
  const apply = (m, sx, sy, sz) => {
    EnhanceModelMaterials(m);
    m.scale.set(sx, sy, sz);
  };
  apply(bunTop, 0.18 * 0.9 * 72, 0.18 * 0.36 * 400, 0.18 * 0.9 * 72);
  apply(bunBottom, 0.18 * 0.9 * 72, 0.18 * 0.36 * 400, 0.18 * 0.9 * 72);
  apply(onion, 0.18 * 0.9 * 14 * 0.8, 0.18 * 0.36 * 22 * 0.8, 0.18 * 0.9 * 14 * 0.8);
  apply(meat, 0.18 * 0.9 * 11.2 * 0.8, 0.18 * 0.36 * 25 * 0.8, 0.18 * 0.9 * 11.2 * 0.8);
  apply(tomato, 0.18 * 0.9 * 12 * 0.8, 0.18 * 0.36 * 24 * 0.8, 0.18 * 0.9 * 12 * 0.8);
  apply(lettuce, 0.18 * 0.9 * 12 * 0.8, 0.18 * 0.36 * 32 * 0.8, 0.18 * 0.9 * 12 * 0.8);
  apply(cheese, 0.18 * 0.9 * 12.6 * 0.8, 0.18 * 0.36 * 28 * 0.8, 0.18 * 0.9 * 12.6 * 0.8);
  return { bunTop, bunBottom, onion, tomato, lettuce, cheese, patty: meat };
}

====== CONTENT OF: burger\src\BurgerNames.js ======
export const BurgerNames = {
    '': { name: 'THE VOID', description: 'Nothing but bun and \npure nothingness.', price: '11' },
    'onion': { name: 'TEARJERKER', description: 'Sharp bite that \nbrings tears of joy.', price: '12' },
    'tomato': { name: 'RED HALO', description: 'Bright, juicy, \na halo of flavor.', price: '12' },
    'lettuce': { name: 'LEAF WHISPER', description: 'Crisp greens that \nspeak in silence.', price: '11' },
    'cheese': { name: 'MELT BOMB', description: 'Soft, molten, and \ndangerously good.', price: '13' },
    'patty': { name: 'SOLO TITAN', description: 'One patty. All power. \nNothing else.', price: '13' },
    'onion,tomato': { name: 'CRIMSON CRY', description: 'Bold and tangy, \nmakes your taste roar.', price: '13' },
    'onion,lettuce': { name: 'GREEN FANG', description: 'Fresh crunch with \na hidden snap.', price: '13' },
    'onion,cheese': { name: 'GOLDEN TEARS', description: 'Sweet onion wrapped \nin molten gold.', price: '13' },
    'onion,patty': { name: 'BEEFSTORM', description: 'Thunder of beef, \nflash of onion.', price: '15' },
    'tomato,lettuce': { name: 'GARDEN KISS', description: 'A soft kiss of \nfreshness and calm.', price: '15' },
    'tomato,cheese': { name: 'SUNBURST MELT', description: 'Sunny tomato draped \nin warm cheese.', price: '12' },
    'tomato,patty': { name: 'BLAZING BULL', description: 'Pure beef fury with \na tomato spark.', price: '13' },
    'lettuce,cheese': { name: 'EMERALD', description: 'Lush green bite \nwith golden warmth.', price: '15' },
    'lettuce,patty': { name: 'SAVANNAH', description: 'Wild and crisp from \nthe open fields.', price: '15' },
    'cheese,patty': { name: 'MIGHTY MELT', description: 'Heavy, cheesy, \nmelts the brave.', price: '17' },
    'onion,tomato,lettuce': { name: 'JUNGLE', description: 'Tangled greens \nand wild energy.', price: '17' },
    'onion,tomato,cheese': { name: 'INFERNO', description: 'Heat and fire tangled \nin golden bliss.', price: '17' },
    'onion,tomato,patty': { name: 'FIREFANG', description: 'Roaring beef with \na searing snap.', price: '17' },
    'onion,lettuce,cheese': { name: 'FROST FANG', description: 'Cool crunch biting \nthrough the melt.', price: '17' },
    'onion,lettuce,patty': { name: 'WILD HOWL', description: 'Rustic power with \na crisp growl.', price: '21' },
    'onion,cheese,patty': { name: 'MOLTEN BEAST', description: 'Lava cheese and \nroaring beef clash.', price: '17' },
    'tomato,lettuce,cheese': { name: 'SOLAR BLOOM', description: 'Bursting with sunny \ngarden charm.', price: '17' },
    'tomato,lettuce,patty': { name: 'SAVAGE', description: 'Fresh, fierce, wild \nand unstoppable.', price: '21' },
    'tomato,cheese,patty': { name: 'LAVA STACK', description: 'Beef and cheese \nerupting in glory.', price: '23' },
    'lettuce,cheese,patty': { name: 'THUNDER LEAF', description: 'Crunch strikes through \nmolten depths.', price: '21' },
    'onion,tomato,lettuce,cheese': { name: 'STORM CROWN', description: 'Crowned in greens, \nthunder below.', price: '21' },
    'onion,tomato,lettuce,patty': { name: 'JUNGLE KING', description: 'Wild reign of leaf \nand fire.', price: '23' },
    'onion,tomato,cheese,patty': { name: 'DRAGON FANG', description: 'Searing bite from \na molten beast.', price: '22' },
    'onion,lettuce,cheese,patty': { name: 'BEASTLORD', description: 'Crunch, melt, and \nprimal power.', price: '23' },
    'tomato,lettuce,cheese,patty': { name: 'PHOENIX BITE', description: 'Born from fire, \nfresh once more.', price: '25' },
    'onion,tomato,lettuce,cheese,patty': { name: 'OMEGA', description: 'Every layer. Every flavor. \nThe final boss.', price: '27' }
};
export function GetCurrentBurgerName(switchStates) {
    if (!Array.isArray(switchStates) || switchStates.length !== 5) {
        return 'THE VOID';
    }
    const ingredientNames = ['onion', 'tomato', 'lettuce', 'cheese', 'patty'];
    const ingredients = [];
    ingredientNames.forEach((name, index) => {
        if (switchStates[index] === true) {
            ingredients.push(name);
        }
    });
    const key = ingredients.join(',');
    const burger = BurgerNames[key] || BurgerNames[''];
    return burger.name;
}
export function GetBurgerData(switchStates) {
    if (!Array.isArray(switchStates) || switchStates.length !== 5) {
        return BurgerNames[''];
    }
    const ingredientNames = ['onion', 'tomato', 'lettuce', 'cheese', 'patty'];
    const ingredients = [];
    ingredientNames.forEach((name, index) => {
        if (switchStates[index] === true) {
            ingredients.push(name);
        }
    });
    const key = ingredients.join(',');
    return BurgerNames[key] || BurgerNames[''];
}

====== CONTENT OF: burger\src\BurgerStack.js ======
import * as THREE from 'three';
import gsap from 'gsap';
export function CreateBurgerStack({
  scene,
  xrRoot,
  mainLight,
  bunTop,
  bunBottom,
  onion,
  tomato,
  lettuce,
  cheese,
  patty
}) {
  const tempGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
  const tempMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.0,
    depthTest: false,
    depthWrite: false
  });
  const baseComposition = new THREE.Mesh(tempGeo, tempMat);
  baseComposition.scale.set(1, 1, 1);
  baseComposition.position.set(0, 1.6, 2); 
  xrRoot.add(baseComposition);
  const root = new THREE.Group();
  root.position.set(0, 0, 0);
  root.rotation.set(0, 0, 0);
  baseComposition.add(root);
  const cubeAGeometry = new THREE.BoxGeometry(1, 1, 1);
  const cubeAMaterial = new THREE.MeshLambertMaterial({
    color: 0x00ff00,
    transparent: true,
    opacity: 0,     
    depthTest: true,
    depthWrite: true
  });
  const cubeA = new THREE.Mesh(cubeAGeometry, cubeAMaterial);
  const cubeBGeometry = new THREE.BoxGeometry(1, 1, 1);
  const cubeBMaterial = new THREE.MeshLambertMaterial({
    color: 0x4ecdc4,
    transparent: true,
    opacity: 0,
    depthTest: true,
    depthWrite: true
  });
  const cubeB = new THREE.Mesh(cubeBGeometry, cubeBMaterial);
  const baseScaleX = 0.18 * 0.9 * 0.8;
  const baseScaleY = 0.18 * 0.36 * 0.8;
  const baseScaleZ = 0.18 * 0.9 * 0.8;
  cubeA.scale.set(baseScaleX, baseScaleY, baseScaleZ);
  cubeB.scale.set(baseScaleX, baseScaleY, baseScaleZ);
  root.add(cubeA);
  root.add(cubeB);
  if (bunTop) {
    bunTop.position.set(0, 0, 0);
    cubeA.add(bunTop);
  }
  if (bunBottom) {
    bunBottom.position.set(0, 0, 0);
    cubeB.add(bunBottom);
  }
  const partGeometry = new THREE.BoxGeometry(0.15, 0.01, 0.15);
  const partMaterial = new THREE.MeshBasicMaterial({
    color: 0xffff00,
    transparent: true,
    opacity: 0
  });
  function CreatePart(name) {
    const mesh = new THREE.Mesh(partGeometry, partMaterial.clone());
    mesh.name = name;
    xrRoot.add(mesh);
    return mesh;
  }
  const part0 = CreatePart('part0'); 
  const part1 = CreatePart('part1'); 
  const part2 = CreatePart('part2'); 
  const part3 = CreatePart('part3'); 
  const part4 = CreatePart('part4'); 
  if (onion) {
    onion.position.set(0, 0, 0);
    part0.add(onion);
  }
  if (tomato) {
    tomato.position.set(0, 0, 0);
    part1.add(tomato);
  }
  if (lettuce) {
    lettuce.position.set(0, 0, 0);
    part2.add(lettuce);
  }
  if (cheese) {
    cheese.position.set(0, 0, 0);
    part3.add(cheese);
  }
  if (patty) {
    patty.position.set(0, 0, 0);
    part4.add(patty);
  }
  const parts = [part0, part1, part2, part3, part4];
  const switchStates = [false, true, true, false, true].map(Boolean);
  parts.forEach((part, index) => {
    const on = switchStates[index];
    part.visible = on;
    part.scale.set(on ? 1 : 0, on ? 1 : 0, on ? 1 : 0);
  });
  const state = {
    joined: true,
    switchStates,
    CalculateGap: null,
    SetSwitchState: null,
    OnSwitchToggle: null
  };
  function CalculateGap() {
    const active = state.switchStates.filter(Boolean).length;
    const baseGap = 0.031;            
    const gapPerIngredient = baseGap / 5;
    return gapPerIngredient * (active + 1); 
  }
  state.CalculateGap = CalculateGap;
  let origPosA = new THREE.Vector3();
  let origPosB = new THREE.Vector3();
  function ApplyCurrentGap() {
    const gap = CalculateGap();
    cubeA.position.set(0, gap, 0);
    cubeB.position.set(0, -gap, 0);
    origPosA.copy(cubeA.position);
    origPosB.copy(cubeB.position);
  }
  ApplyCurrentGap();
  function SetSwitchState(index, on) {
    if (index < 0 || index >= state.switchStates.length) return;
    const value = Boolean(on);
    const part = parts[index];
    if (state.switchStates[index] === value) return;
    state.switchStates[index] = value;
    if (value) {
      part.visible = true;
      part.scale.set(0, 0, 0);
      gsap.to(part.scale, {
        x: 1,
        y: 1,
        z: 1,
        duration: 0.3,
        ease: 'back.out(1.7)'
      });
    } else {
      gsap.to(part.scale, {
        x: 0,
        y: 0,
        z: 0,
        duration: 0.2,
        ease: 'power2.in',
        onComplete: () => {
          part.visible = false;
        }
      });
    }
    if (state.joined) {
      ApplyCurrentGap();
    }
    if (typeof state.OnSwitchToggle === 'function') {
      state.OnSwitchToggle(index, value);
    }
  }
  state.SetSwitchState = SetSwitchState;
  const _aWorld = new THREE.Vector3();
  const _bWorld = new THREE.Vector3();
  const _dirAB = new THREE.Vector3();
  const _aQuat = new THREE.Quaternion();
  function UpdateContentParts() {
    cubeA.getWorldPosition(_aWorld);
    cubeB.getWorldPosition(_bWorld);
    _dirAB.subVectors(_bWorld, _aWorld);
    cubeA.getWorldQuaternion(_aQuat);
    const n = parts.length;
    for (let i = 0; i < n; i++) {
      const t = (i + 1) / (n + 1); 
      const part = parts[i];
      const pos = new THREE.Vector3().copy(_aWorld).addScaledVector(_dirAB, t);
      part.position.copy(pos);
      part.quaternion.copy(_aQuat);
    }
  }
  UpdateContentParts();
  return {
    baseComposition,
    root,
    cubeA,
    cubeB,
    parts,
    state,
    UpdateContentParts
  };
}

====== CONTENT OF: burger\src\BurgerUI.js ======
import * as THREE from 'three';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
import gsap from 'gsap';
import { GetBurgerData } from './BurgerNames.js';
export function CreateBurgerUI({ scene, xrRoot, switchStates, cubeA, cubeB }) {
  const getSwitchStates = () => switchStates;
  const textureLoader = new THREE.TextureLoader();
  const fontLoader = new FontLoader();
  const mainUITexture = textureLoader.load('/static/ui_main.png');
  mainUITexture.encoding = THREE.sRGBEncoding;
  const switchTextures = [
    { OFF: textureLoader.load('/static/ui_switch0_OFF.png'), ON: textureLoader.load('/static/ui_switch0_ON.png') },
    { OFF: textureLoader.load('/static/ui_switch1_OFF.png'), ON: textureLoader.load('/static/ui_switch1_ON.png') },
    { OFF: textureLoader.load('/static/ui_switch2_OFF.png'), ON: textureLoader.load('/static/ui_switch2_ON.png') },
    { OFF: textureLoader.load('/static/ui_switch3_OFF.png'), ON: textureLoader.load('/static/ui_switch3_ON.png') },
    { OFF: textureLoader.load('/static/ui_switch4_OFF.png'), ON: textureLoader.load('/static/ui_switch4_ON.png') }
  ];
  switchTextures.forEach(pair => {
    pair.OFF.encoding = THREE.sRGBEncoding;
    pair.ON.encoding = THREE.sRGBEncoding;
  });
  const initialSwitchTextures = [
    switchTextures[0].OFF, 
    switchTextures[1].ON,   
    switchTextures[2].ON,   
    switchTextures[3].OFF, 
    switchTextures[4].ON   
  ];
  const mainUIGeometry = new THREE.PlaneGeometry(0.22, 0.22);
  const mainUIMaterial = new THREE.MeshBasicMaterial({
    map: mainUITexture,
    transparent: true,
    opacity: 1.0,
    side: THREE.FrontSide
  });
  const mainUI = new THREE.Mesh(mainUIGeometry, mainUIMaterial);
  mainUI.position.set(0, 1.6, -1);
  mainUI.visible = false;
  mainUI.scale.set(0, 0, 0);
  xrRoot.add(mainUI);
  const partUIGeometry = new THREE.PlaneGeometry(0.140, 0.0547);
  const partUIs = [];
  for (let i = 0; i < 5; i++) {
    const material = new THREE.MeshBasicMaterial({
      map: initialSwitchTextures[i],
      transparent: true,
      opacity: 1.0,
      side: THREE.FrontSide
    });
    const partUI = new THREE.Mesh(partUIGeometry, material);
    partUI.position.copy(mainUI.position);
    partUI.visible = false;
    xrRoot.add(partUI);
    partUIs.push(partUI);
  }
  const uiRefGeometry = new THREE.SphereGeometry(0.01, 16, 16);
  const uiRefMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const openUIRef = new THREE.Mesh(uiRefGeometry, uiRefMaterial);
  openUIRef.visible = false;
  openUIRef.position.set(0, 1.6, -0.5);
  xrRoot.add(openUIRef);
  const partUIRefs = [];
  for (let i = 0; i < 5; i++) {
    const ref = new THREE.Mesh(uiRefGeometry, uiRefMaterial.clone());
    ref.visible = false;
    ref.position.copy(openUIRef.position);
    xrRoot.add(ref);
    partUIRefs.push(ref);
  }
  const arrowTexture = textureLoader.load('/static/ui_arrow.png');
  arrowTexture.encoding = THREE.sRGBEncoding;
  const arrowGeometry = new THREE.PlaneGeometry(0.2016, 0.2016);
  const arrowMaterial = new THREE.MeshBasicMaterial({
    map: arrowTexture,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 1.0,
    depthTest: false
  });
  const topArrowPlane = new THREE.Mesh(arrowGeometry, arrowMaterial.clone());
  topArrowPlane.name = 'topArrowPlane';
  topArrowPlane.position.set(0, 0.8, 0);
  topArrowPlane.scale.set(1, 2.5, 1); 
  topArrowPlane.renderOrder = 999;
  cubeA.add(topArrowPlane);
  const bottomArrowPlane = new THREE.Mesh(arrowGeometry, arrowMaterial.clone());
  bottomArrowPlane.name = 'bottomArrowPlane';
  bottomArrowPlane.position.set(0, -0.8, 0);
  bottomArrowPlane.scale.set(1, 2.5, 1);
  bottomArrowPlane.renderOrder = 999;
  bottomArrowPlane.rotation.x = Math.PI; 
  cubeB.add(bottomArrowPlane);
  let fontBlack, fontBold, fontMedium;
  let mainUIText = null;
  let textMaterial, textMaterial3;
  const fontPromises = [
    new Promise((r) => fontLoader.load('/static/fonts/roboto_black.typeface.json', r)),
    new Promise((r) => fontLoader.load('/static/fonts/helvetiker_bold.typeface.json', r)),
    new Promise((r) => fontLoader.load('/static/fonts/helvetiker_bold.typeface.json', r))
  ];
  Promise.all(fontPromises).then(([black, bold, medium]) => {
    fontBlack = black;
    fontBold = bold;
    fontMedium = medium;
    initMainUIText();
  });
  function safeRemove(node) {
    node?.traverse?.((o) => {
      if (o.geometry) o.geometry.dispose();
      if (o.material) {
        if (Array.isArray(o.material)) {
          o.material.forEach((m) => m && m.dispose && m.dispose());
        } else if (o.material.dispose) {
          o.material.dispose();
        }
      }
    });
    node?.parent?.remove(node);
  }
  function initMainUIText() {
    textMaterial = new THREE.MeshBasicMaterial({ color: 0xFFCF00 });
    textMaterial3 = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
    mainUIText = new THREE.Group();
    const fixedLeftPosition = -0.102;
    const currentSwitchStates = getSwitchStates();
    const initialBurgerData = GetBurgerData(currentSwitchStates);
    const [descLine1, descLine2] = initialBurgerData.description.split('\n');
    const textGeometry3a = new TextGeometry(descLine1, {
      font: fontMedium,
      size: 0.011,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    const textGeometry3b = new TextGeometry(descLine2, {
      font: fontMedium,
      size: 0.011,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    textGeometry3a.computeBoundingBox();
    textGeometry3b.computeBoundingBox();
    const height3a = textGeometry3a.boundingBox.max.y - textGeometry3a.boundingBox.min.y;
    textGeometry3a.translate(0, -height3a * 2, 0.001);
    textGeometry3b.translate(0, -height3a * 3, 0.001);
    const textMesh3a = new THREE.Mesh(textGeometry3a, textMaterial3);
    const textMesh3b = new THREE.Mesh(textGeometry3b, textMaterial3);
    textMesh3a.position.set(0.001, -0.02 + 0.045, 0);
    textMesh3b.position.set(0.001, -0.025 + 0.045, 0);
    const textGeometry1 = new TextGeometry(initialBurgerData.name, {
      font: fontBlack,
      size: 0.025,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    const textGeometry2 = new TextGeometry('BURGER', {
      font: fontBlack,
      size: 0.025,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    textGeometry1.computeBoundingBox();
    textGeometry2.computeBoundingBox();
    const height1 = textGeometry1.boundingBox.max.y - textGeometry1.boundingBox.min.y;
    const height2 = textGeometry2.boundingBox.max.y - textGeometry2.boundingBox.min.y;
    textGeometry1.translate(0, height1 / 2, 0.001);
    textGeometry2.translate(0, -height2 / 2, 0.001);
    const textMesh1 = new THREE.Mesh(textGeometry1, textMaterial);
    const textMesh2 = new THREE.Mesh(textGeometry2, textMaterial);
    textMesh1.position.y = 0.004 + 0.04;
    textMesh2.position.y = -0.004 + 0.04;
    const textGeometry4 = new TextGeometry(initialBurgerData.price, {
      font: fontBold,
      size: 0.028,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    const textMaterial4 = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
    const textMesh4 = new THREE.Mesh(textGeometry4, textMaterial4);
    textMesh4.position.set(0.12, -0.06 - 0.018, 0);
    mainUIText.add(textMesh1);
    mainUIText.add(textMesh2);
    mainUIText.add(textMesh3a);
    mainUIText.add(textMesh3b);
    mainUIText.add(textMesh4);
    mainUIText.position.x = fixedLeftPosition;
    mainUI.add(mainUIText);
  }
  function updateBurgerText() {
    if (!mainUIText || !fontBlack || !fontMedium || !fontBold) return;
    const currentSwitchStates = getSwitchStates();
    const burgerData = GetBurgerData(currentSwitchStates);
    const [d1, d2] = burgerData.description.split('\n');
    for (let i = mainUIText.children.length - 1; i >= 0; i--) {
      const child = mainUIText.children[i];
      safeRemove(child);
    }
    const tg1 = new TextGeometry(burgerData.name, {
      font: fontBlack,
      size: 0.025,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    const tg2 = new TextGeometry('BURGER', {
      font: fontBlack,
      size: 0.025,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    const tg3a = new TextGeometry(d1, {
      font: fontMedium,
      size: 0.011,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    const tg3b = new TextGeometry(d2, {
      font: fontMedium,
      size: 0.011,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    tg1.computeBoundingBox();
    tg2.computeBoundingBox();
    tg3a.computeBoundingBox();
    tg3b.computeBoundingBox();
    const h1 = tg1.boundingBox.max.y - tg1.boundingBox.min.y;
    const h2 = tg2.boundingBox.max.y - tg2.boundingBox.min.y;
    const h3a = tg3a.boundingBox.max.y - tg3a.boundingBox.min.y;
    tg1.translate(0, h1 / 2, 0.001);
    tg2.translate(0, -h2 / 2, 0.001);
    tg3a.translate(0, -h3a * 2, 0.001);
    tg3b.translate(0, -h3a * 3, 0.001);
    const tm1 = new THREE.Mesh(tg1, textMaterial);
    const tm2 = new THREE.Mesh(tg2, textMaterial);
    const tm3a = new THREE.Mesh(tg3a, textMaterial3);
    const tm3b = new THREE.Mesh(tg3b, textMaterial3);
    tm1.position.y = 0.004 + 0.04;
    tm2.position.y = -0.004 + 0.04;
    tm3a.position.set(0.001, -0.02 + 0.045, 0);
    tm3b.position.set(0.001, -0.025 + 0.045, 0);
    const tg4 = new TextGeometry(burgerData.price, {
      font: fontBold,
      size: 0.028,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    const tm4 = new THREE.Mesh(tg4, new THREE.MeshBasicMaterial({ color: 0xFFFFFF }));
    tm4.position.set(0.12, -0.06 - 0.018, 0);
    mainUIText.add(tm1);
    mainUIText.add(tm2);
    mainUIText.add(tm3a);
    mainUIText.add(tm3b);
    mainUIText.add(tm4);
    mainUIText.position.x = -0.102;
  }
  function updateSwitchTexture(index, isOn) {
    if (index < 0 || index >= partUIs.length) return;
    partUIs[index].material.map = switchTextures[index][isOn ? 'ON' : 'OFF'];
    partUIs[index].material.needsUpdate = true;
  }
  function updateMainUIPosition(camera) {
    mainUI.position.copy(openUIRef.position);
    const cameraPos = new THREE.Vector3();
    camera.getWorldPosition(cameraPos);
    const deltaX = cameraPos.x - mainUI.position.x;
    const deltaZ = cameraPos.z - mainUI.position.z;
    const angleY = Math.atan2(deltaX, deltaZ);
    mainUI.rotation.set(0, angleY, 0);
  }
  function showMainUIWithAnimation() {
    mainUI.visible = true;
    gsap.to(mainUI.scale, {
      x: 1,
      y: 1,
      z: 1,
      duration: 0.25,
      ease: "power2.out"
    });
  }
  function animateArrowPlanes(clock) {
    if (topArrowPlane) {
      const time = clock.getElapsedTime();
      const baseY = 1;
      const amplitude = 0.05;
      const frequency = 8;
      topArrowPlane.position.y = baseY + Math.sin(time * frequency) * amplitude;
    }
    if (bottomArrowPlane) {
      const time = clock.getElapsedTime();
      const baseY = -0.8;
      const amplitude = 0.05;
      const frequency = 8;
      bottomArrowPlane.position.y = baseY - Math.sin(time * frequency) * amplitude;
    }
  }
  function setSwitchStatesRef(newSwitchStates) {
    switchStates = newSwitchStates;
  }
  return {
    mainUI,
    partUIs,
    openUIRef,
    partUIRefs,
    topArrowPlane,
    bottomArrowPlane,
    updateBurgerText,
    updateSwitchTexture,
    updateMainUIPosition,
    showMainUIWithAnimation,
    animateArrowPlanes,
    setSwitchStatesRef
  };
}

====== CONTENT OF: burger\src\HandTracking.js ======
import * as THREE from 'three';
export function CreateHandTracking({
  scene,
  camera,
  renderer,
  xrRoot,
  root,
  cubeA,
  cubeB,
  parts,                
  mainLight,            
  state,                
  mainUI,
  partUIs,              
  openUIRef,
  topArrowPlane,
  bottomArrowPlane,
  UpdateMainUIPosition,
  ShowMainUIWithAnimation,
  OnSwitchToggle,        
  OnRejoin               
}) {
  const fingertipGeo = new THREE.SphereGeometry(0.002, 16, 16);
  const fingertipMat = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    opacity: 0,
    transparent: true
  });
  const lThumbObj = new THREE.Mesh(fingertipGeo, fingertipMat.clone());
  const lIndexObj = new THREE.Mesh(fingertipGeo, fingertipMat.clone());
  const rThumbObj = new THREE.Mesh(fingertipGeo, fingertipMat.clone());
  const rIndexObj = new THREE.Mesh(fingertipGeo, fingertipMat.clone());
  xrRoot.add(lThumbObj, lIndexObj, rThumbObj, rIndexObj);
  const pinchGeo = new THREE.SphereGeometry(0.006, 16, 16);
  const pinchMatL = new THREE.MeshLambertMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0
  });
  const pinchMatR = new THREE.MeshLambertMaterial({
    color: 0x00ff00,
    transparent: true,
    opacity: 0
  });
  const lPinchSphere = new THREE.Mesh(pinchGeo, pinchMatL);
  const rPinchSphere = new THREE.Mesh(pinchGeo, pinchMatR);
  xrRoot.add(lPinchSphere, rPinchSphere);
  lPinchSphere.visible = true;
  rPinchSphere.visible = true;
  const hand1 = renderer.xr.getHand(0);
  const hand2 = renderer.xr.getHand(1);
  const handsGroup = new THREE.Group();
  handsGroup.add(hand1, hand2);
  xrRoot.add(handsGroup);
  handsGroup.visible = true;
  let lPinchOn = false;
  let rPinchOn = false;
  let leftHandGrabbing = false;
  let rightHandGrabbing = false;
  let grabbedObject = null;
  let originalParent = null;
  let originalPosition = null;
  let originalRotation = null;
  const grabDistance = 0.15;
  const grabOffset = 0.05;
  let pinchDetectionEnabled = true; 
  const switchCooldowns = [0, 0, 0, 0, 0];
  const SWITCH_COOLDOWN_MS = 500;
  const _rootWorldPos = new THREE.Vector3();
  const _cameraPos = new THREE.Vector3();
  const _tmpVec = new THREE.Vector3();
  const _aWorld = new THREE.Vector3();
  const _bWorld = new THREE.Vector3();
  const _aQuat = new THREE.Quaternion();
  function CheckPointPlaneIntersection(point, plane) {
    if (!plane || !plane.visible) return false;
    const planePos = new THREE.Vector3();
    const planeQuat = new THREE.Quaternion();
    plane.getWorldPosition(planePos);
    plane.getWorldQuaternion(planeQuat);
    const inv = new THREE.Matrix4().makeRotationFromQuaternion(planeQuat).invert();
    const localPoint = point.clone().sub(planePos).applyMatrix4(inv);
    const width = plane.geometry.parameters.width / 2;
    const height = plane.geometry.parameters.height / 2;
    return (
      Math.abs(localPoint.x) < width &&
      Math.abs(localPoint.y) < height &&
      Math.abs(localPoint.z) < 0.02
    );
  }
  function ToggleSwitch(index) {
    const now = Date.now();
    if (now - switchCooldowns[index] < SWITCH_COOLDOWN_MS) return;
    switchCooldowns[index] = now;
    const current = state.switchStates[index];
    const next = !current;
    state.SetSwitchState(index, next);
    if (typeof OnSwitchToggle === 'function') {
      OnSwitchToggle(index, next);
    }
  }
  function UpdateHandTracking() {
    const leftHand = hand1;
    const rightHand = hand2;
    if (leftHand && leftHand.joints) {
      const lThumb = leftHand.joints['thumb-tip'];
      const lIndex = leftHand.joints['index-finger-tip'];
      if (lThumb) {
        lThumbObj.position.copy(lThumb.position);
        lThumbObj.rotation.setFromQuaternion(lThumb.quaternion || lThumbObj.quaternion);
      }
      if (lIndex) {
        lIndexObj.position.copy(lIndex.position);
        lIndexObj.rotation.setFromQuaternion(lIndex.quaternion || lIndexObj.quaternion);
        if (Array.isArray(partUIs)) {
          partUIs.forEach((plane, i) => {
            if (CheckPointPlaneIntersection(lIndexObj.position, plane)) {
              ToggleSwitch(i);
            }
          });
        }
      }
    }
    if (rightHand && rightHand.joints) {
      const rThumb = rightHand.joints['thumb-tip'];
      const rIndex = rightHand.joints['index-finger-tip'];
      if (rThumb) {
        rThumbObj.position.copy(rThumb.position);
        rThumbObj.rotation.setFromQuaternion(rThumb.quaternion || rThumbObj.quaternion);
      }
      if (rIndex) {
        rIndexObj.position.copy(rIndex.position);
        rIndexObj.rotation.setFromQuaternion(rIndex.quaternion || rIndexObj.quaternion);
        if (Array.isArray(partUIs)) {
          partUIs.forEach((plane, i) => {
            if (CheckPointPlaneIntersection(rIndexObj.position, plane)) {
              ToggleSwitch(i);
            }
          });
        }
      }
    }
    const lDist = lIndexObj.position.distanceTo(lThumbObj.position);
    if (pinchDetectionEnabled && lDist < 0.02) {
      lPinchSphere.position.copy(lThumbObj.position);
      lPinchSphere.rotation.copy(lThumbObj.rotation);
      lPinchOn = true;
      if (!leftHandGrabbing && !rightHandGrabbing && state.joined) {
        root.getWorldPosition(_rootWorldPos);
        const distanceToRoot = lPinchSphere.position.distanceTo(_rootWorldPos);
        if (distanceToRoot < grabDistance) {
          leftHandGrabbing = true;
          grabbedObject = root;
          originalParent = root.parent;
          originalPosition = root.position.clone();
          originalRotation = root.rotation.clone();
          const worldQuat = root.getWorldQuaternion(new THREE.Quaternion());
          lPinchSphere.add(root);
          root.position.set(0, 0, -grabOffset);
          const parentWorldQuat = lPinchSphere.getWorldQuaternion(new THREE.Quaternion());
          const localQuat = worldQuat.clone().multiply(parentWorldQuat.invert());
          root.quaternion.copy(localQuat);
        }
      }
    } else {
      lPinchOn = false;
      if (leftHandGrabbing && grabbedObject) {
        leftHandGrabbing = false;
        const currentWorldPosition = new THREE.Vector3();
        const currentWorldQuaternion = new THREE.Quaternion();
        grabbedObject.getWorldPosition(currentWorldPosition);
        grabbedObject.getWorldQuaternion(currentWorldQuaternion);
        originalParent.add(grabbedObject);
        const localPosition = currentWorldPosition.clone();
        originalParent.worldToLocal(localPosition);
        grabbedObject.position.copy(localPosition);
        const parentWorldQuat = originalParent.getWorldQuaternion(new THREE.Quaternion());
        const localQuat = currentWorldQuaternion.clone().multiply(parentWorldQuat.invert());
        grabbedObject.quaternion.copy(localQuat);
        grabbedObject = null;
        originalParent = null;
        originalPosition = null;
        originalRotation = null;
        if (state.joined && openUIRef && mainUI) {
          root.getWorldPosition(_rootWorldPos);
          camera.getWorldPosition(_cameraPos);
          const distanceToBurger = _rootWorldPos.distanceTo(_cameraPos);
          const angleToCamera = Math.atan2(
            _rootWorldPos.x - _cameraPos.x,
            _rootWorldPos.z - _cameraPos.z
          );
          const angleOffset = distanceToBurger <= 0.6 ? 30 : 20;
          const newAngle = angleToCamera - THREE.MathUtils.degToRad(angleOffset);
          const newX = _cameraPos.x + Math.sin(newAngle) * distanceToBurger;
          const newZ = _cameraPos.z + Math.cos(newAngle) * distanceToBurger;
          openUIRef.position.set(newX, _rootWorldPos.y, newZ);
          if (UpdateMainUIPosition) UpdateMainUIPosition();
          if (ShowMainUIWithAnimation) {
            mainUI.scale.set(0, 0, 0);
            ShowMainUIWithAnimation();
          } else {
            mainUI.visible = true;
            mainUI.scale.set(1, 1, 1);
          }
        }
      }
    }
    const rDist = rIndexObj.position.distanceTo(rThumbObj.position);
    if (pinchDetectionEnabled && rDist < 0.02) {
      rPinchSphere.position.copy(rThumbObj.position);
      rPinchSphere.rotation.copy(rThumbObj.rotation);
      rPinchOn = true;
      if (!leftHandGrabbing && !rightHandGrabbing && state.joined) {
        root.getWorldPosition(_rootWorldPos);
        const distanceToRoot = rPinchSphere.position.distanceTo(_rootWorldPos);
        if (distanceToRoot < grabDistance) {
          rightHandGrabbing = true;
          grabbedObject = root;
          originalParent = root.parent;
          originalPosition = root.position.clone();
          originalRotation = root.rotation.clone();
          const worldQuat = root.getWorldQuaternion(new THREE.Quaternion());
          rPinchSphere.add(root);
          root.position.set(0, 0, -grabOffset);
          const parentWorldQuat = rPinchSphere.getWorldQuaternion(new THREE.Quaternion());
          const localQuat = worldQuat.clone().multiply(parentWorldQuat.invert());
          root.quaternion.copy(localQuat);
        }
      }
    } else {
      rPinchOn = false;
      if (rightHandGrabbing && grabbedObject) {
        rightHandGrabbing = false;
        const currentWorldPosition = new THREE.Vector3();
        const currentWorldQuaternion = new THREE.Quaternion();
        grabbedObject.getWorldPosition(currentWorldPosition);
        grabbedObject.getWorldQuaternion(currentWorldQuaternion);
        originalParent.add(grabbedObject);
        const localPosition = currentWorldPosition.clone();
        originalParent.worldToLocal(localPosition);
        grabbedObject.position.copy(localPosition);
        const parentWorldQuat = originalParent.getWorldQuaternion(new THREE.Quaternion());
        const localQuat = currentWorldQuaternion.clone().multiply(parentWorldQuat.invert());
        grabbedObject.quaternion.copy(localQuat);
        grabbedObject = null;
        originalParent = null;
        originalPosition = null;
        originalRotation = null;
        if (state.joined && openUIRef && mainUI) {
          root.getWorldPosition(_rootWorldPos);
          camera.getWorldPosition(_cameraPos);
          const distanceToBurger = _rootWorldPos.distanceTo(_cameraPos);
          const angleToCamera = Math.atan2(
            _rootWorldPos.x - _cameraPos.x,
            _rootWorldPos.z - _cameraPos.z
          );
          const angleOffset = distanceToBurger <= 0.6 ? 30 : 20;
          const newAngle = angleToCamera - THREE.MathUtils.degToRad(angleOffset);
          const newX = _cameraPos.x + Math.sin(newAngle) * distanceToBurger;
          const newZ = _cameraPos.z + Math.cos(newAngle) * distanceToBurger;
          openUIRef.position.set(newX, _rootWorldPos.y, newZ);
          if (UpdateMainUIPosition) UpdateMainUIPosition();
          if (ShowMainUIWithAnimation) {
            mainUI.scale.set(0, 0, 0);
            ShowMainUIWithAnimation();
          } else {
            mainUI.visible = true;
            mainUI.scale.set(1, 1, 1);
          }
        }
      }
    }
  }
  function UpdateOpening() {
    if (!state.joined) return;
    if (!(lPinchOn && rPinchOn)) return;
    const lPinchWorld = new THREE.Vector3();
    const rPinchWorld = new THREE.Vector3();
    lPinchSphere.getWorldPosition(lPinchWorld);
    rPinchSphere.getWorldPosition(rPinchWorld);
    const cubeAWorld = new THREE.Vector3();
    const cubeBWorld = new THREE.Vector3();
    cubeA.getWorldPosition(cubeAWorld);
    cubeB.getWorldPosition(cubeBWorld);
    const grabThreshold = 0.15;
    const leftNearA = lPinchWorld.distanceTo(cubeAWorld) < grabThreshold;
    const leftNearB = lPinchWorld.distanceTo(cubeBWorld) < grabThreshold;
    const rightNearA = rPinchWorld.distanceTo(cubeAWorld) < grabThreshold;
    const rightNearB = rPinchWorld.distanceTo(cubeBWorld) < grabThreshold;
    const oppositeHalves =
      (leftNearA && rightNearB) ||
      (leftNearB && rightNearA);
    if (!oppositeHalves) return;
    state.joined = false;
    if (mainUI) mainUI.visible = false;
    if (topArrowPlane) topArrowPlane.visible = false;
    if (bottomArrowPlane) bottomArrowPlane.visible = false;
    parts.forEach((part, i) => {
      part.visible = state.switchStates[i];
    });
  }
  function UpdateFreeMove() {
    if (state.joined) return;
    const lPinchWorld = new THREE.Vector3();
    const rPinchWorld = new THREE.Vector3();
    lPinchSphere.getWorldPosition(lPinchWorld);
    rPinchSphere.getWorldPosition(rPinchWorld);
    const cubeAWorld = new THREE.Vector3();
    const cubeBWorld = new THREE.Vector3();
    cubeA.getWorldPosition(cubeAWorld);
    cubeB.getWorldPosition(cubeBWorld);
    const threshold = 0.15;
    let movingHalves = false;
    if (lPinchOn) {
      const dA = lPinchWorld.distanceTo(cubeAWorld);
      const dB = lPinchWorld.distanceTo(cubeBWorld);
      if (dA < threshold && dA < dB) {
        const local = lPinchWorld.clone();
        root.worldToLocal(local);
        cubeA.position.copy(local);
        movingHalves = true;
      } else if (dB < threshold && dB < dA) {
        const local = lPinchWorld.clone();
        root.worldToLocal(local);
        cubeB.position.copy(local);
        movingHalves = true;
      }
    }
    if (rPinchOn) {
      const dA = rPinchWorld.distanceTo(cubeAWorld);
      const dB = rPinchWorld.distanceTo(cubeBWorld);
      if (dA < threshold && dA < dB) {
        const local = rPinchWorld.clone();
        root.worldToLocal(local);
        cubeA.position.copy(local);
        movingHalves = true;
      } else if (dB < threshold && dB < dA) {
        const local = rPinchWorld.clone();
        root.worldToLocal(local);
        cubeB.position.copy(local);
        movingHalves = true;
      }
    }
    if (movingHalves) {
      UpdatePartUIs();
    }
  }
  function UpdatePartUIs() {
    if (!Array.isArray(partUIs) || partUIs.length !== parts.length) return;
    camera.getWorldPosition(_cameraPos);
    parts.forEach((part, index) => {
      const uiPlane = partUIs[index];
      if (!uiPlane) return;
      const partWorldPos = new THREE.Vector3();
      part.getWorldPosition(partWorldPos);
      const toPart = new THREE.Vector3().subVectors(partWorldPos, _cameraPos);
      const toPartXZ = new THREE.Vector3(toPart.x, 0, toPart.z);
      const xzDist = toPartXZ.length();
      const yOffset = toPart.y;
      const angleToCamera = Math.atan2(toPartXZ.x, toPartXZ.z);
      const newAngle = angleToCamera - THREE.MathUtils.degToRad(20.5);
      const newX = _cameraPos.x + Math.sin(newAngle) * xzDist;
      const newZ = _cameraPos.z + Math.cos(newAngle) * xzDist;
      uiPlane.position.set(newX, _cameraPos.y + yOffset, newZ);
      uiPlane.visible = true;
      const deltaX = _cameraPos.x - uiPlane.position.x;
      const deltaZ = _cameraPos.z - uiPlane.position.z;
      const angleY = Math.atan2(deltaX, deltaZ);
      uiPlane.rotation.set(0, angleY, 0);
    });
  }
  function UpdateRejoin() {
    if (state.joined) return;
    if (lPinchOn || rPinchOn) return;
    cubeA.getWorldPosition(_aWorld);
    cubeB.getWorldPosition(_bWorld);
    const distance = _aWorld.distanceTo(_bWorld);
    const rejoinThreshold = 0.2;
    if (distance >= rejoinThreshold) return;
    const midpoint = new THREE.Vector3()
      .addVectors(_aWorld, _bWorld)
      .multiplyScalar(0.5);
    const localMid = midpoint.clone();
    root.parent.worldToLocal(localMid);
    root.position.copy(localMid);
    const gap = state.CalculateGap
      ? state.CalculateGap()
      : 0.031;
    cubeA.position.set(0, gap, 0);
    cubeB.position.set(0, -gap, 0);
    cubeA.rotation.set(0, 0, 0);
    cubeB.rotation.set(0, 0, 0);
    state.joined = true;
    if (Array.isArray(partUIs)) {
      partUIs.forEach(ui => ui && (ui.visible = false));
    }
    if (mainUI) {
      if (ShowMainUIWithAnimation) {
        mainUI.scale.set(0, 0, 0);
        mainUI.visible = true;
        ShowMainUIWithAnimation();
      } else {
        mainUI.visible = true;
        mainUI.scale.set(1, 1, 1);
      }
    }
    if (openUIRef && UpdateMainUIPosition) {
      root.getWorldPosition(_rootWorldPos);
      camera.getWorldPosition(_cameraPos);
      const distanceToBurger = _rootWorldPos.distanceTo(_cameraPos);
      const angleToCamera = Math.atan2(
        _rootWorldPos.x - _cameraPos.x,
        _rootWorldPos.z - _cameraPos.z
      );
      const newAngle = angleToCamera - THREE.MathUtils.degToRad(30);
      const newX = _cameraPos.x + Math.sin(newAngle) * distanceToBurger;
      const newZ = _cameraPos.z + Math.cos(newAngle) * distanceToBurger;
      openUIRef.position.set(newX, _rootWorldPos.y, newZ);
      UpdateMainUIPosition();
    }
    if (typeof OnRejoin === 'function') {
      OnRejoin();
    }
  }
  function UpdateOpenState() {
    if (state.joined) return;
    cubeA.getWorldPosition(_aWorld);
    cubeB.getWorldPosition(_bWorld);
    const distanceAB = _aWorld.distanceTo(_bWorld);
    const orientationThreshold = 0.12;
    if (distanceAB <= orientationThreshold) return;
    cubeA.lookAt(_bWorld);
    cubeB.lookAt(_aWorld);
    const MODEL_FRONT = new THREE.Vector3(0, 1, 0);
    const corr = new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 0, -1),
      MODEL_FRONT.clone().normalize()
    );
    cubeA.quaternion.multiply(corr);
    cubeB.quaternion.multiply(corr);
    const flip = new THREE.Quaternion().setFromAxisAngle(
      new THREE.Vector3(0, 0, 1),
      Math.PI
    );
    cubeA.quaternion.multiply(flip);
  }
  function OnXRSessionStart() {
    pinchDetectionEnabled = true;
  }
  function OnXRSessionEnd() {
    pinchDetectionEnabled = false;
    lPinchOn = false;
    rPinchOn = false;
    leftHandGrabbing = false;
    rightHandGrabbing = false;
    grabbedObject = null;
  }
  return {
    UpdateHandTracking,
    UpdateOpening,
    UpdateFreeMove,
    UpdateRejoin,
    UpdateOpenState,
    OnXRSessionStart,
    OnXRSessionEnd
  };
}

====== CONTENT OF: burger\src\Lights.js ======
import * as THREE from 'three';
export function CreateLights(xrRoot) {
  const ambient = new THREE.AmbientLight(0xffffff, 1.0);
  xrRoot.add(ambient);
  const main = new THREE.DirectionalLight(0xffffff, 1.8);
  main.position.set(4, 10, 5);
  main.castShadow = true;
  main.shadow.mapSize.width = 1536;
  main.shadow.mapSize.height = 1536;
  main.shadow.camera.near = 0.1;
  main.shadow.camera.far = 100;
  main.shadow.camera.left = -5;
  main.shadow.camera.right = 5;
  main.shadow.camera.top = 5;
  main.shadow.camera.bottom = -5;
  main.shadow.bias = -0.0005;
  main.shadow.normalBias = 0.04;
  main.shadow.radius = 3;
  xrRoot.add(main);
  const fill = new THREE.DirectionalLight(0x8899ff, 0.9);
  fill.position.set(-4, 7, -4);
  fill.castShadow = false;
  xrRoot.add(fill);
  const _tmpBox = new THREE.Box3();
  const _tmpVec = new THREE.Vector3();
  const _bboxCorners = [
    new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(),
    new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()
  ];
  function fitShadowCameraToObject(light, object, margin = 0.15) {
    if (!light || !light.shadow || !light.shadow.camera || !object) return;
    const cam = light.shadow.camera;
    object.updateWorldMatrix(true, true);
    light.updateMatrixWorld(true);
    cam.updateMatrixWorld(true);
    cam.updateProjectionMatrix();
    _tmpBox.setFromObject(object);
    if (!_tmpBox || !isFinite(_tmpBox.min.x) || !isFinite(_tmpBox.max.x)) return;
    _tmpBox.min.addScalar(-margin);
    _tmpBox.max.addScalar(margin);
    const min = _tmpBox.min;
    const max = _tmpBox.max;
    _bboxCorners[0].set(min.x, min.y, min.z);
    _bboxCorners[1].set(max.x, min.y, min.z);
    _bboxCorners[2].set(min.x, max.y, min.z);
    _bboxCorners[3].set(max.x, max.y, min.z);
    _bboxCorners[4].set(min.x, min.y, max.z);
    _bboxCorners[5].set(max.x, min.y, max.z);
    _bboxCorners[6].set(min.x, max.y, max.z);
    _bboxCorners[7].set(max.x, max.y, max.z);
    const invCamMatrix = cam.matrixWorldInverse.clone();
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    for (let i = 0; i < 8; i++) {
      _tmpVec.copy(_bboxCorners[i]).applyMatrix4(invCamMatrix);
      if (_tmpVec.x < minX) minX = _tmpVec.x;
      if (_tmpVec.x > maxX) maxX = _tmpVec.x;
      if (_tmpVec.y < minY) minY = _tmpVec.y;
      if (_tmpVec.y > maxY) maxY = _tmpVec.y;
      if (_tmpVec.z < minZ) minZ = _tmpVec.z;
      if (_tmpVec.z > maxZ) maxZ = _tmpVec.z;
    }
    cam.left = minX;
    cam.right = maxX;
    cam.bottom = minY;
    cam.top = maxY;
    cam.near = Math.max(0.1, -maxZ);
    cam.far = Math.max(cam.near + 0.1, -minZ);
    cam.updateProjectionMatrix();
    light.shadow.needsUpdate = true;
  }
  return {
    mainLight: main,
    fitShadowCameraToObject
  };
}

====== CONTENT OF: burger\src\main.js ======
import * as THREE from 'three';
import gsap from 'gsap';
import { SetupXRScene } from './XRScene.js';
import { CreateBurgerMaterials } from './BurgerMaterials.js';
import { LoadBurgerModels } from './BurgerModels.js';
import { CreateBurgerStack } from './BurgerStack.js';
import { CreateLights } from './Lights.js';
import { CreateBurgerUI } from './BurgerUI.js';
import { CreateHandTracking } from './HandTracking.js';
gsap.ticker.lagSmoothing(0);
gsap.ticker.fps(60);
console.log = function() {};
const { scene, camera, renderer, xrRoot, clock, onXRSessionStart, onXRSessionEnd, positionCompositionAtHeadHeight, isCompositionPositioned } = SetupXRScene();
const { EnhanceModelMaterials } = CreateBurgerMaterials();
let models = null;
LoadBurgerModels(EnhanceModelMaterials).then(loadedModels => {
  models = loadedModels;
  initializeApp();
});
function initializeApp() {
  if (!models) return;
  const { mainLight, fitShadowCameraToObject } = CreateLights(xrRoot);
  const burgerStack = CreateBurgerStack({
    scene,
    xrRoot,
    mainLight,
    bunTop: models.bunTop,
    bunBottom: models.bunBottom,
    onion: models.onion.clone(),
    tomato: models.tomato.clone(),
    lettuce: models.lettuce.clone(),
    cheese: models.cheese.clone(),
    patty: models.patty.clone()
  });
  const { baseComposition, root, cubeA, cubeB, parts, state, UpdateContentParts } = burgerStack;
  const burgerUI = CreateBurgerUI({
    scene,
    xrRoot,
    switchStates: state.switchStates,
    cubeA,
    cubeB
  });
  const {
    mainUI,
    partUIs,
    openUIRef,
    partUIRefs,
    topArrowPlane,
    bottomArrowPlane,
    updateBurgerText,
    updateSwitchTexture,
    updateMainUIPosition,
    showMainUIWithAnimation,
    animateArrowPlanes,
    setSwitchStatesRef
  } = burgerUI;
  setSwitchStatesRef(state.switchStates);
  state.OnSwitchToggle = (index, isOn) => {
    updateSwitchTexture(index, isOn);
    updateBurgerText();
    if (state.joined) {
      fitShadowCameraToObject(mainLight, root, 0.15);
    }
  };
  updateBurgerText();
  fitShadowCameraToObject(mainLight, root, 0.15);
  const handTracking = CreateHandTracking({
    scene,
    camera,
    renderer,
    xrRoot,
    root,
    cubeA,
    cubeB,
    parts,
    mainLight,
    state,
    mainUI,
    partUIs,
    openUIRef,
    topArrowPlane,
    bottomArrowPlane,
    UpdateMainUIPosition: () => updateMainUIPosition(camera),
    ShowMainUIWithAnimation: showMainUIWithAnimation,
    OnSwitchToggle: (index, newState) => {
      state.SetSwitchState(index, newState);
    },
    OnRejoin: () => {
      updateBurgerText();
      fitShadowCameraToObject(mainLight, root, 0.15);
    }
  });
  const {
    UpdateHandTracking,
    UpdateOpening,
    UpdateFreeMove,
    UpdateRejoin,
    UpdateOpenState,
    OnXRSessionStart,
    OnXRSessionEnd
  } = handTracking;
  let pinchDetectionEnabled = false;
  onXRSessionStart(() => {
    pinchDetectionEnabled = false;
    OnXRSessionStart();
    setTimeout(() => {
      if (!isCompositionPositioned()) return;
      const rootWorldPos = new THREE.Vector3();
      root.getWorldPosition(rootWorldPos);
      const cameraPos = new THREE.Vector3();
      camera.getWorldPosition(cameraPos);
      const distanceToBurger = rootWorldPos.distanceTo(cameraPos);
      const angleToCamera = Math.atan2(
        rootWorldPos.x - cameraPos.x,
        rootWorldPos.z - cameraPos.z
      );
      const angleOffset = 12;
      const newAngle = angleToCamera - THREE.MathUtils.degToRad(angleOffset);
      const newX = cameraPos.x + Math.sin(newAngle) * distanceToBurger;
      const newZ = cameraPos.z + Math.cos(newAngle) * distanceToBurger;
      openUIRef.position.set(newX, rootWorldPos.y, newZ);
      updateMainUIPosition(camera);
      mainUI.scale.set(0, 0, 0);
      showMainUIWithAnimation();
    }, 1500);
    setTimeout(() => {
      pinchDetectionEnabled = true;
    }, 2000);
  });
  onXRSessionEnd(() => {
    pinchDetectionEnabled = false;
    OnXRSessionEnd();
  });
  renderer.setAnimationLoop(() => {
    const delta = clock.getDelta();
    gsap.ticker.tick(delta);
    positionCompositionAtHeadHeight(baseComposition);
    if (pinchDetectionEnabled) {
      UpdateHandTracking();
    }
    UpdateOpening();
    UpdateFreeMove();
    UpdateRejoin();
    UpdateOpenState();
    UpdateContentParts();
    animateArrowPlanes(clock);
    renderer.render(scene, camera);
  });
}

====== CONTENT OF: burger\src\style.css ======
.webgl
{
    position: fixed;
    top: 0;
    left: 0
}
html, 
body 
{
    overflow: hidden;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}
/* Add a click instruction overlay */
body::before {
    content: "Start WebXR";
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #ffff00;
    color: #000;
    padding: 20px 40px;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: 18px;
    font-weight: bold;
    z-index: 1000;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
/* Hide instruction when in XR */
body.xr-presenting::before {
    opacity: 0;
}
/* Force-hide default Three.js WebXR buttons */
#XRButton,
#VRButton {
    display: none !important;
}

====== CONTENT OF: burger\src\XRScene.js ======
import * as THREE from 'three';
import { XRButton } from 'three/addons/webxr/XRButton.js';
export function SetupXRScene() {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 50);
  camera.position.set(0, 1.6, 3);
  scene.add(camera);
  const renderer = new THREE.WebGLRenderer({
    antialias: false,
    shadowMap: {
      enabled: true,
      type: THREE.PCFSoftShadowMap
    }
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);
  const xrRoot = new THREE.Group();
  xrRoot.visible = false;
  scene.add(xrRoot);
  const xrButton = XRButton.createButton(renderer, { optionalFeatures: ['hand-tracking'] });
  xrButton.style.display = 'none';
  document.body.appendChild(xrButton);
  document.body.style.cursor = 'pointer';
  document.body.addEventListener('click', () => {
    xrButton.click();
  });
  document.body.style.transition = 'background-color 0.3s ease';
  document.body.addEventListener('mouseenter', () => {
    document.body.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
  });
  document.body.addEventListener('mouseleave', () => {
    document.body.style.backgroundColor = '';
  });
  const clock = new THREE.Clock();
  const startCbs = [];
  const endCbs = [];
  let xrSessionStartTime = null;
  let compositionPositioned = false;
  renderer.xr.addEventListener('sessionstart', () => {
    xrSessionStartTime = Date.now();
    compositionPositioned = false;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2));
    document.body.classList.add('xr-presenting');
    xrRoot.visible = true;
    startCbs.forEach(fn => fn());
  });
  renderer.xr.addEventListener('sessionend', () => {
    xrSessionStartTime = null;
    compositionPositioned = false;
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.classList.remove('xr-presenting');
    xrRoot.visible = false;
    endCbs.forEach(fn => fn());
  });
  function onXRSessionStart(fn) {
    startCbs.push(fn);
  }
  function onXRSessionEnd(fn) {
    endCbs.push(fn);
  }
  function positionCompositionAtHeadHeight(baseComposition) {
    if (compositionPositioned || !xrSessionStartTime || !baseComposition) return;
    const elapsedTime = Date.now() - xrSessionStartTime;
    if (elapsedTime < 1000) {
      return;
    }
    const headHeight = camera.position.y;
    const headDistance = camera.position.z;
    baseComposition.position.set(0, headHeight - 0.2, headDistance - 1.0);
    compositionPositioned = true;
  }
  function getXRSessionStartTime() {
    return xrSessionStartTime;
  }
  function isCompositionPositioned() {
    return compositionPositioned;
  }
  return {
    scene,
    camera,
    renderer,
    xrRoot,
    clock,
    onXRSessionStart,
    onXRSessionEnd,
    positionCompositionAtHeadHeight,
    getXRSessionStartTime,
    isCompositionPositioned
  };
}

====== CONTENT OF: chair\index.html ======
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Chair Demo</title>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body>
    <canvas class ="webgl"> </canvas>
    <script type="module" src="./src/main.js"></script>
</body>
</html>

====== CONTENT OF: chair\vite.config.js ======
import glsl from 'vite-plugin-glsl'
export default {
    root: './',
    publicDir: './public/',
    base: './',
    server:
    {
        host: true, 
        open: !('SANDBOX_URL' in process.env || 'CODESANDBOX_HOST' in process.env) 
    },
    build:
    {
        outDir: './dist', 
        emptyOutDir: true, 
        sourcemap: true 
    },
    plugins:
    [
        glsl()
    ]
}

====== CONTENT OF: chair\public\static\shaders\fresnel_fragment.glsl ======
uniform float outlineThickness;
uniform vec3 outlineColor;
varying vec3 vNormal;
varying vec3 vViewPosition;
void main() {
    // Calculate the Fresnel term
    float fresnelFactor = dot(normalize(vViewPosition), normalize(vNormal));
    fresnelFactor = 0.5 / fresnelFactor;
    fresnelFactor = pow(fresnelFactor, outlineThickness);       // Fresnel
    //fresnelFactor = step(0.7, fresnelFactor);                // Outline
    // Set the color of the outline based on the Fresnel term
    gl_FragColor = vec4(outlineColor, fresnelFactor);
}

====== CONTENT OF: chair\public\static\shaders\fresnel_vertex.glsl ======
varying vec3 vNormal;
varying vec3 vViewPosition;
void main() {
    // Pass the normal and view position to the fragment shader
    vNormal = normalize(normalMatrix * normal);
    vec4 viewPosition = modelViewMatrix * vec4(position, 1.0);
    vViewPosition = -viewPosition.xyz;
    gl_Position = projectionMatrix * viewPosition;
}

====== CONTENT OF: chair\public\static\shaders\sizes_fragment.glsl ======
uniform vec3 baseColor;
uniform float opacity;
varying vec3 vNormal;
varying vec3 vViewPosition;
varying vec2 vUv;
void main() {
    // Simple plain white color
    gl_FragColor = vec4(baseColor, opacity);
}

====== CONTENT OF: chair\public\static\shaders\sizes_vertex.glsl ======
varying vec3 vNormal;
varying vec3 vViewPosition;
varying vec2 vUv;
void main() {
    // Pass the normal and view position to the fragment shader
    vNormal = normalize(normalMatrix * normal);
    vec4 viewPosition = modelViewMatrix * vec4(position, 1.0);
    vViewPosition = -viewPosition.xyz;
    // Pass UV coordinates for texture mapping
    vUv = uv;
    gl_Position = projectionMatrix * viewPosition;
}

====== CONTENT OF: chair\src\ChairExperience.js ======
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { HDRLoader } from 'three/examples/jsm/loaders/HDRLoader.js';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
import gsap from 'gsap';
import { createUIPanels } from './UIPanels.js';
import {
  preloadSizesShaders,
  getOrCreateSizesMaterial,
  applyFresnelToChair,
  restoreOriginalMaterials
} from './Shaders.js';
const UP_VECTOR = new THREE.Vector3(0, 1, 0);
export class ChairExperience {
  constructor(scene, camera, renderer, handInput) {
    this.scene = scene;
    this.camera = camera;
    this.renderer = renderer;
    this.handInput = handInput;
    this.baseComposition = null;
    this.chairModel = null;
    this.sizesModel = null;
    this.buttonState = false;          
    this.headerToggleIsRight = false;  
    this.delta = 0;
    this.clock = new THREE.Clock();
    this.stringMesh = null;
    this.switchButton = null;
    this.switchRoot = null;
    this.pullPlane = null;
    this.headerToggleLastTouchMs = 0;
    this.HEADER_TOGGLE_TOUCH_COOLDOWN_MS = 400;
    this.switchButtonAttached = false;
    this.switchPullCount = 0;
    this.buttonCooldowns = {
      button1: 0,
      button2: 0,
      button3: 0
    };
    this.BUTTON_COOLDOWN_TIME = 500;
    this.buttonResetTimers = {
      button1: 0,
      button2: 0,
      button3: 0
    };
    this.BUTTON_RESET_DELAY = 300;
    this.plasticMaterials = [];
    this.MAX_PR = 1.5;
    this.targetMs = 1000 / 72;
    this.adaptivePR = Math.min(window.devicePixelRatio, this.MAX_PR);
    this.accum = 0;
    this.compositionPositioned = false;
    this.xrSessionStartTime = null;
    this._vA = new THREE.Vector3();
    this._vB = new THREE.Vector3();
    this._vC = new THREE.Vector3();
    this._q = new THREE.Quaternion();
    this._tmp1 = new THREE.Vector3();
    this._tmp2 = new THREE.Vector3();
    this._tmp3 = new THREE.Vector3();
  }
  initLights() {
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    this.scene.add(ambientLight);
    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
    mainLight.position.set(5, 8, 3);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(512, 512);
    mainLight.shadow.bias = -0.0005;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 50;
    mainLight.shadow.camera.left = -10;
    mainLight.shadow.camera.right = 10;
    mainLight.shadow.camera.top = 10;
    mainLight.shadow.camera.bottom = -10;
    mainLight.shadow.autoUpdate = false;
    this.scene.add(mainLight);
    this.mainLight = mainLight;
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
    fillLight.position.set(-3, 6, -2);
    this.scene.add(fillLight);
  }
  initBaseComposition() {
    const tempGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
    const tempMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.0,
      depthTest: false,
      depthWrite: false
    });
    this.baseComposition = new THREE.Mesh(tempGeo, tempMat);
    this.baseComposition.scale.set(1, 1, 1);
    this.baseComposition.visible = false; 
    this.scene.add(this.baseComposition);
  }
  setupEnvMap() {
    const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
    pmremGenerator.compileEquirectangularShader();
    const hdrLoader = new HDRLoader();
    hdrLoader.load('/static/2k.hdr', hdrTexture => {
      const envRT = pmremGenerator.fromEquirectangular(hdrTexture);
      this.scene.environment = envRT.texture;
      hdrTexture.dispose();
      pmremGenerator.dispose();
    });
  }
  async loadModelsAndUI() {
    const loader = new GLTFLoader();
    const chairGltf = await loader.loadAsync('/static/chair.glb');
    this.chairModel = chairGltf.scene;
    this.chairModel.scale.set(0.5, 0.5, 0.5);
    this.chairModel.position.set(0, -0.25, 0);
    this.chairModel.rotation.set(0, -0.7, 0);
    this.chairModel.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        child.userData.isOriginalChair = true;
      }
    });
    this.baseComposition.add(this.chairModel);
    this.improveMaterials(this.chairModel);
    window.refreshChairMaterials = () => this.improveMaterials(this.chairModel);
    const sizesGltf = await loader.loadAsync('/static/sizes.glb');
    this.sizesModel = sizesGltf.scene;
    await preloadSizesShaders();
    const sizesMat = getOrCreateSizesMaterial();
    this.sizesModel.traverse(child => {
      if (child.isMesh) {
        child.material = sizesMat;
        child.castShadow = true;
        child.receiveShadow = true;
        child.renderOrder = 1000;
      }
    });
    this.chairModel.add(this.sizesModel);
    this.sizesModel.visible = false;
    this.createSizeLabels();
    const ui = createUIPanels(this.baseComposition);
    Object.assign(this, ui);
    const stringGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.1, 8);
    const stringMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    this.stringMesh = new THREE.Mesh(stringGeo, stringMat);
    this.baseComposition.add(this.stringMesh);
  }
  createSizeLabels() {
    if (!this.sizesModel) return;
    const fontLoader = new FontLoader();
    fontLoader.load('/static/fonts/helvetiker_regular.typeface.json', font => {
      const geo0 = new TextGeometry('16.0"', {
        font,
        size: 0.04,
        depth: 0,
        curveSegments: 12,
        bevelEnabled: false
      });
      const mat0 = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1.0
      });
      const sizeTextMesh0 = new THREE.Mesh(geo0, mat0);
      geo0.computeBoundingBox();
      sizeTextMesh0.position.x -= geo0.boundingBox.max.x * 0.5; 
      sizeTextMesh0.position.y = 0.2;
      sizeTextMesh0.position.z = 0.03;
      this.sizesModel.add(sizeTextMesh0);
      const geo1 = new TextGeometry('31.5"', {
        font,
        size: 0.04,
        depth: 0,
        curveSegments: 12,
        bevelEnabled: false
      });
      const mat1 = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1.0
      });
      const sizeTextMesh1 = new THREE.Mesh(geo1, mat1);
      geo1.computeBoundingBox();
      sizeTextMesh1.position.x = -geo1.boundingBox.max.x * 0.5 + 0.06;
      sizeTextMesh1.position.y = 0.43;
      sizeTextMesh1.position.z = -0.34;
      sizeTextMesh1.rotation.y = Math.PI / 2;
      this.sizesModel.add(sizeTextMesh1);
      const geo2 = new TextGeometry('24.5"', {
        font,
        size: 0.04,
        depth: 0,
        curveSegments: 12,
        bevelEnabled: false
      });
      const mat2 = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1.0
      });
      const sizeTextMesh2 = new THREE.Mesh(geo2, mat2);
      geo2.computeBoundingBox();
      sizeTextMesh2.position.x = -geo2.boundingBox.max.x * 0.5;
      sizeTextMesh2.position.y = 0.0;
      sizeTextMesh2.position.z = 0.27;
      sizeTextMesh2.rotation.x = -Math.PI / 2;
      this.sizesModel.add(sizeTextMesh2);
      const geo3 = new TextGeometry('23.5"', {
        font,
        size: 0.04,
        depth: 0,
        curveSegments: 12,
        bevelEnabled: false
      });
      const mat3 = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1.0
      });
      const sizeTextMesh3 = new THREE.Mesh(geo3, mat3);
      geo3.computeBoundingBox();
      sizeTextMesh3.position.x = -geo3.boundingBox.max.x * 0.5 + 0.35;
      sizeTextMesh3.position.y = 0.0;
      sizeTextMesh3.position.z = 0.06;
      sizeTextMesh3.rotation.x = sizeTextMesh2.rotation.x; 
      sizeTextMesh3.rotation.y = 0;
      sizeTextMesh3.rotation.z = Math.PI / 2;
      this.sizesModel.add(sizeTextMesh3);
    });
  }
  improveMaterials(model) {
    if (!model) return;
    model.traverse(child => {
      if (child.isMesh && child.material) {
        if (Array.isArray(child.material)) {
          child.material = child.material.map(mat => this.createImprovedMaterial(mat));
        } else {
          child.material = this.createImprovedMaterial(child.material);
        }
      }
    });
  }
  createImprovedMaterial(originalMat) {
    const props = this.getMaterialProperties(originalMat.name);
    const cfg = {
      color: props.color,
      roughness: props.roughness,
      metalness: props.metalness,
      envMapIntensity: props.envMapIntensity
    };
    if (originalMat.map) cfg.map = originalMat.map;
    if (originalMat.normalMap) {
      cfg.normalMap = originalMat.normalMap;
      cfg.normalScale = new THREE.Vector2(1, 1);
    }
    if (originalMat.roughnessMap) cfg.roughnessMap = originalMat.roughnessMap;
    if (originalMat.metalnessMap) cfg.metalnessMap = originalMat.metalnessMap;
    if (originalMat.aoMap) cfg.aoMap = originalMat.aoMap;
    const mat = new THREE.MeshStandardMaterial(cfg);
    mat.name = originalMat.name || 'ImprovedMaterial';
    if (mat.name.includes('Plastic')) this.plasticMaterials.push(mat);
    return mat;
  }
  getMaterialProperties(name = '') {
    if (name === 'Metal') {
      return {
        color: 0x888888,
        roughness: 0.15,
        metalness: 0.9,
        envMapIntensity: 1.2
      };
    }
    if (name === 'BlackMetal') {
      return {
        color: 0x444444,
        roughness: 0.2,
        metalness: 0.9,
        envMapIntensity: 1.0
      };
    }
    if (name.includes('Plastic')) {
      return {
        color: 0x4682b4,
        roughness: 0.25,
        metalness: 0.0,
        envMapIntensity: 2.0
      };
    }
    if (name.includes('Wood')) {
      return {
        color: 0xbd884a,
        roughness: 0.8,
        metalness: 0.0,
        envMapIntensity: 0.4
      };
    }
    return {
      color: 0x4682b4,
      roughness: 0.7,
      metalness: 0.1,
      envMapIntensity: 1.0
    };
  }
  changePlasticMaterialColor(newColor) {
    if (!this.plasticMaterials.length) return;
    const c = new THREE.Color(newColor);
    this.plasticMaterials.forEach(mat => mat.color.copy(c));
  }
  onSessionStart() {
    this.xrSessionStartTime = Date.now();
    this.compositionPositioned = false;
    if (this.baseComposition) this.baseComposition.visible = true;
    document.body.classList.add('xr-presenting');
  }
  onSessionEnd() {
    this.xrSessionStartTime = null;
    this.compositionPositioned = false;
    if (this.baseComposition) this.baseComposition.visible = false;
    document.body.classList.remove('xr-presenting');
  }
  positionCompositionAtHeadHeight() {
    if (this.compositionPositioned || !this.xrSessionStartTime || !this.baseComposition) return;
    const elapsedTime = Date.now() - this.xrSessionStartTime;
    if (elapsedTime < 1000) return;
    const headHeight = this.camera.position.y;
    const headDistance = this.camera.position.z;
    this.baseComposition.position.set(0, headHeight - 0.2, headDistance - 1.0);
    this.compositionPositioned = true;
  }
  stringUpdate() {
    if (!this.stringMesh || !this.switchButton || !this.switchRoot) return;
    const A = this._vA.copy(this.switchRoot.position);
    const B = this._vB.copy(this.switchButton.position);
    const dir = this._vC.subVectors(B, A);
    const dist = dir.length();
    this.stringMesh.position.copy(A).addScaledVector(dir, 0.5);
    this.stringMesh.scale.setY(dist / 0.1);
    if (dist > 0.001) {
      dir.normalize();
      this._q.setFromUnitVectors(UP_VECTOR, dir);
      this.stringMesh.quaternion.copy(this._q);
    }
  }
  updateToggleTextColors() {
    if (!this.materialTextMesh || !this.sizesTextMesh) return;
    if (this.headerToggleIsRight) {
      if (this.materialTextMesh.userData?.defaultMaterial) {
        this.materialTextMesh.material = this.materialTextMesh.userData.defaultMaterial;
      }
      if (this.sizesTextMesh.userData?.activeMaterial) {
        this.sizesTextMesh.material = this.sizesTextMesh.userData.activeMaterial;
      }
    } else {
      if (this.materialTextMesh.userData?.activeMaterial) {
        this.materialTextMesh.material = this.materialTextMesh.userData.activeMaterial;
      }
      if (this.sizesTextMesh.userData?.defaultMaterial) {
        this.sizesTextMesh.material = this.sizesTextMesh.userData.defaultMaterial;
      }
    }
  }
  setHeaderToggleState(stateBool, animate = true) {
    this.headerToggleIsRight = !!stateBool;
    if (this.headerToggleSwitchMesh && this.togglePosA && this.togglePosB) {
      const target = this.headerToggleIsRight ? this.togglePosB : this.togglePosA;
      gsap.killTweensOf(this.headerToggleSwitchMesh.position);
      if (animate) {
        gsap.to(this.headerToggleSwitchMesh.position, {
          duration: 0.25,
          x: target.x,
          y: target.y,
          z: target.z,
          ease: 'power2.inOut'
        });
      } else {
        this.headerToggleSwitchMesh.position.copy(target);
      }
    }
    this.updateToggleTextColors();
    if (this.buttonState && this.chairModel) {
      if (this.headerToggleIsRight) {
        applyFresnelToChair(this.chairModel);
      } else {
        restoreOriginalMaterials(this.chairModel);
      }
    }
    if (this.sizesModel) {
      this.sizesModel.visible = this.buttonState && this.headerToggleIsRight;
    }
  }
  handleHeaderToggleTouch(availableHands) {
    if (!this.headerToggle || !this.headerToggleSwitchMesh || !this.togglePosA || !this.togglePosB) {
      return;
    }
    this.headerToggle.localToWorld(this._vA.copy(this.togglePosA));
    this.headerToggle.localToWorld(this._vB.copy(this.togglePosB));
    const touchThreshold = 0.04;
    let nearLeft = false;
    let nearRight = false;
    for (let i = 0; i < availableHands.length; i++) {
      const hand = availableHands[i];
      if (!hand || !hand.joints) continue;
      const indexJoint = hand.joints['index-finger-tip'];
      if (!indexJoint) continue;
      const indexPos = indexJoint.position;
      nearLeft = nearLeft || indexPos.distanceTo(this._vA) < touchThreshold;
      nearRight = nearRight || indexPos.distanceTo(this._vB) < touchThreshold;
    }
    const nowMs = performance.now();
    const cooldownPassed =
      nowMs - this.headerToggleLastTouchMs > this.HEADER_TOGGLE_TOUCH_COOLDOWN_MS;
    if ((nearLeft || nearRight) && cooldownPassed) {
      this.setHeaderToggleState(!this.headerToggleIsRight);
      this.headerToggleLastTouchMs = nowMs;
    }
  }
  handleSwitchButton() {
    if (!this.switchButton || !this.baseComposition || !this.switchRoot || !this.handInput) return;
    const lPinchOn = this.handInput.lPinchOn;
    const rPinchOn = this.handInput.rPinchOn;
    const lPinchSphere = this.handInput.lPinchSphere;
    const rPinchSphere = this.handInput.rPinchSphere;
    let activePinchSphere = null;
    let activePinchOn = false;
    if (lPinchOn && rPinchOn) {
      const lDist = lPinchSphere.position.distanceTo(this.switchButton.position);
      const rDist = rPinchSphere.position.distanceTo(this.switchButton.position);
      activePinchSphere = lDist < rDist ? lPinchSphere : rPinchSphere;
      activePinchOn = true;
    } else if (lPinchOn) {
      activePinchSphere = lPinchSphere;
      activePinchOn = true;
    } else if (rPinchOn) {
      activePinchSphere = rPinchSphere;
      activePinchOn = true;
    }
    if (activePinchSphere && activePinchOn) {
      activePinchSphere.getWorldPosition(this._tmp1);
      this.switchButton.getWorldPosition(this._tmp2);
      const distanceToButton = this._tmp1.distanceTo(this._tmp2);
      if (distanceToButton < 0.08 && !this.switchButtonAttached) {
        this.switchButtonAttached = true;
      }
      if (this.switchButtonAttached) {
        activePinchSphere.getWorldPosition(this._tmp1);
        const localPos = this.baseComposition.worldToLocal(this._tmp1.clone());
        this.switchButton.position.copy(localPos);
      }
    }
    if (!lPinchOn && !rPinchOn && this.switchButtonAttached) {
      const switchRootWorld = this._tmp1;
      this.switchRoot.getWorldPosition(switchRootWorld);
      const localTarget = this.baseComposition.worldToLocal(switchRootWorld.clone());
      this.buttonState = !this.buttonState;
      this.updateChairState();
      gsap.to(this.switchButton.position, {
        duration: 0.6,
        x: localTarget.x,
        y: localTarget.y,
        z: localTarget.z,
        ease: 'elastic.out(0.5, 0.2)'
      });
      this.switchButtonAttached = false;
      this.switchPullCount++;
      if (this.switchPullCount >= 2 && this.pullPlane) {
        this.pullPlane.visible = false;
      }
    }
  }
  isButtonOnCooldown(buttonName) {
    const now = performance.now();
    return now - this.buttonCooldowns[buttonName] < this.BUTTON_COOLDOWN_TIME;
  }
  setButtonCooldown(buttonName) {
    this.buttonCooldowns[buttonName] = performance.now();
  }
  updateButtonStrokes(activeButton) {
    if (!this.buttonStroke1Mesh || !this.buttonStroke2Mesh || !this.buttonStroke3Mesh) return;
    gsap.to(this.buttonStroke1Mesh.scale, { duration: 0.2, x: 0, y: 0, z: 0, ease: 'power2.out' });
    gsap.to(this.buttonStroke2Mesh.scale, { duration: 0.2, x: 0, y: 0, z: 0, ease: 'power2.out' });
    gsap.to(this.buttonStroke3Mesh.scale, { duration: 0.2, x: 0, y: 0, z: 0, ease: 'power2.out' });
    const STROKE_DELAY = 0.3;
    let targetMesh = null;
    if (activeButton === 'button1') targetMesh = this.buttonStroke1Mesh;
    if (activeButton === 'button2') targetMesh = this.buttonStroke2Mesh;
    if (activeButton === 'button3') targetMesh = this.buttonStroke3Mesh;
    if (!targetMesh) return;
    gsap.to(targetMesh.scale, {
      duration: 0.2,
      delay: STROKE_DELAY,
      x: 1,
      y: 1,
      z: 1,
      ease: 'power2.out'
    });
  }
  handleColorButtons(availableHands, nowMs) {
    if (!this.button1Mesh || !this.button2Mesh || !this.button3Mesh) return;
    if (this.buttonState) return;
    let buttonPressed = false;
    for (let i = 0; i < availableHands.length && !buttonPressed; i++) {
      const hand = availableHands[i];
      if (!hand || !hand.joints) continue;
      const indexJoint = hand.joints['index-finger-tip'];
      if (!indexJoint) continue;
      const indexPos = indexJoint.position;
      this.button1Mesh.getWorldPosition(this._vA);
      this.button2Mesh.getWorldPosition(this._vB);
      this.button3Mesh.getWorldPosition(this._vC);
      const d1 = indexPos.distanceTo(this._vA);
      const d2 = indexPos.distanceTo(this._vB);
      const d3 = indexPos.distanceTo(this._vC);
      if (d1 < 0.03 && !this.isButtonOnCooldown('button1')) {
        this.changePlasticMaterialColor(0x4682b4); 
        gsap.killTweensOf(this.button1Mesh.scale);
        gsap.to(this.button1Mesh.scale, {
          duration: 0.2,
          x: 0.8,
          y: 0.8,
          z: 0.8,
          ease: 'power2.out'
        });
        this.updateButtonStrokes('button1');
        this.setButtonCooldown('button1');
        this.buttonResetTimers.button1 = nowMs + this.BUTTON_RESET_DELAY;
        buttonPressed = true;
      } else if (d2 < 0.03 && !this.isButtonOnCooldown('button2')) {
        this.changePlasticMaterialColor(0xb20000); 
        gsap.killTweensOf(this.button2Mesh.scale);
        gsap.to(this.button2Mesh.scale, {
          duration: 0.2,
          x: 0.8,
          y: 0.8,
          z: 0.8,
          ease: 'power2.out'
        });
        this.updateButtonStrokes('button2');
        this.setButtonCooldown('button2');
        this.buttonResetTimers.button2 = nowMs + this.BUTTON_RESET_DELAY;
        buttonPressed = true;
      } else if (d3 < 0.03 && !this.isButtonOnCooldown('button3')) {
        this.changePlasticMaterialColor(0xf08805); 
        gsap.killTweensOf(this.button3Mesh.scale);
        gsap.to(this.button3Mesh.scale, {
          duration: 0.2,
          x: 0.8,
          y: 0.8,
          z: 0.8,
          ease: 'power2.out'
        });
        this.updateButtonStrokes('button3');
        this.setButtonCooldown('button3');
        this.buttonResetTimers.button3 = nowMs + this.BUTTON_RESET_DELAY;
        buttonPressed = true;
      }
    }
    if (nowMs > this.buttonResetTimers.button1) {
      gsap.killTweensOf(this.button1Mesh.scale);
      gsap.to(this.button1Mesh.scale, {
        duration: 0.2,
        x: 1,
        y: 1,
        z: 1,
        ease: 'power2.out'
      });
    }
    if (nowMs > this.buttonResetTimers.button2) {
      gsap.killTweensOf(this.button2Mesh.scale);
      gsap.to(this.button2Mesh.scale, {
        duration: 0.2,
        x: 1,
        y: 1,
        z: 1,
        ease: 'power2.out'
      });
    }
    if (nowMs > this.buttonResetTimers.button3) {
      gsap.killTweensOf(this.button3Mesh.scale);
      gsap.to(this.button3Mesh.scale, {
        duration: 0.2,
        x: 1,
        y: 1,
        z: 1,
        ease: 'power2.out'
      });
    }
  }
  updateChairState() {
    if (!this.chairModel) return;
    if (this.renderer.shadowMap) {
      this.renderer.shadowMap.needsUpdate = true;
    }
    if (this.mainLight && this.mainLight.shadow) {
      this.mainLight.shadow.needsUpdate = true;
    }
    if (this.buttonState) {
      gsap.to(this.chairModel.scale, {
        duration: 0.5,
        x: 1.1,
        y: 1.1,
        z: 1.1,
        ease: 'power2.out'
      });
      gsap.to(this.chairModel.position, {
        duration: 0.5,
        x: 0,
        y: -1.35,
        z: 0,
        ease: 'power2.out'
      });
      if (this.uiFrame) {
        gsap.to(this.uiFrame.scale, {
          duration: 0.3,
          x: 0,
          y: 0,
          z: 0,
          ease: 'power2.out'
        });
      }
      if (this.infoPanel) {
        gsap.to(this.infoPanel.scale, {
          duration: 0.3,
          x: 0,
          y: 0,
          z: 0,
          ease: 'power2.out'
        });
      }
      if (this.colorPanel) {
        gsap.to(this.colorPanel.scale, {
          duration: 0.3,
          x: 0,
          y: 0,
          z: 0,
          ease: 'power2.out'
        });
      }
      if (this.headerToggle) {
        gsap.to(this.headerToggle.scale, {
          duration: 0.3,
          x: 1,
          y: 1,
          z: 1,
          ease: 'power2.out'
        });
      }
      this.updateToggleTextColors();
      if (this.headerToggleIsRight) {
        applyFresnelToChair(this.chairModel);
      } else {
        restoreOriginalMaterials(this.chairModel);
      }
      if (this.sizesModel) {
        this.sizesModel.visible = this.headerToggleIsRight;
      }
    } else {
      gsap.to(this.chairModel.scale, {
        duration: 0.4,
        x: 0.5,
        y: 0.5,
        z: 0.5,
        ease: 'power2.out'
      });
      gsap.to(this.chairModel.position, {
        duration: 0.4,
        x: 0,
        y: -0.25,
        z: 0,
        ease: 'power2.out'
      });
      if (this.uiFrame) {
        gsap.to(this.uiFrame.scale, {
          duration: 0.3,
          x: 1,
          y: 1,
          z: 1,
          ease: 'power2.out'
        });
      }
      if (this.infoPanel) {
        gsap.to(this.infoPanel.scale, {
          duration: 0.3,
          x: 1,
          y: 1,
          z: 1,
          ease: 'power2.out'
        });
      }
      if (this.colorPanel) {
        gsap.to(this.colorPanel.scale, {
          duration: 0.3,
          x: 1,
          y: 1,
          z: 1,
          ease: 'power2.out'
        });
      }
      if (this.headerToggle) {
        gsap.to(this.headerToggle.scale, {
          duration: 0.3,
          x: 0,
          y: 0,
          z: 0,
          ease: 'power2.out'
        });
        this.setHeaderToggleState(false, false);
      }
      this.updateToggleTextColors();
      restoreOriginalMaterials(this.chairModel);
      if (this.sizesModel) {
        this.sizesModel.visible = false;
      }
    }
  }
  update(delta, t) {
    this.delta = delta;
    const ms = delta * 1000;
    this.accum = 0.9 * this.accum + 0.1 * ms;
    if (this.accum > this.targetMs * 1.15 && this.adaptivePR > 1.0) {
      this.adaptivePR = Math.max(1.0, this.adaptivePR - 0.05);
      this.renderer.setPixelRatio(this.adaptivePR);
    } else if (this.accum < this.targetMs * 0.9 && this.adaptivePR < this.MAX_PR) {
      this.adaptivePR = Math.min(this.MAX_PR, this.adaptivePR + 0.05);
      this.renderer.setPixelRatio(this.adaptivePR);
    }
    if (this.handInput && this.chairModel) {
      this.handInput.onRotateChair = deltaRot => {
        this.chairModel.rotation.y += deltaRot;
      };
      this.handInput.update(delta, {
        chairModel: this.chairModel
      });
    }
    const availableHands = [];
    if (this.handInput?.hand1 && this.handInput.hand1.joints) {
      availableHands.push(this.handInput.hand1);
    }
    if (this.handInput?.hand2 && this.handInput.hand2.joints) {
      availableHands.push(this.handInput.hand2);
    }
    const nowMs = performance.now();
    if (availableHands.length) {
      this.handleHeaderToggleTouch(availableHands);
      this.handleColorButtons(availableHands, nowMs);
    }
    this.handleSwitchButton();
    this.stringUpdate();
    this.positionCompositionAtHeadHeight();
    if (this.pullPlane && this.pullPlane.visible) {
      const amplitude = 0.005;
      const frequency = 1.0;
      const timeInSeconds = t / 1000;
      const offset = Math.sin(timeInSeconds * frequency * Math.PI * 2) * amplitude;
      this.pullPlane.position.y = 0.31 + offset;
    }
  }
}

====== CONTENT OF: chair\src\HandInput.js ======
import * as THREE from 'three';
const JOINT_RADIUS = 0.002;
const PINCH_RADIUS = 0.006;
const PINCH_THRESHOLD = 0.02;
export class HandInput {
  constructor(renderer, scene) {
    this.renderer = renderer;
    this.scene = scene;
    const jointGeo = new THREE.SphereGeometry(JOINT_RADIUS, 16, 16);
    const jointMat = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      opacity: 0,
      transparent: true
    });
    this.lThumbObj = new THREE.Mesh(jointGeo, jointMat.clone());
    this.lIndexObj = new THREE.Mesh(jointGeo, jointMat.clone());
    this.rThumbObj = new THREE.Mesh(jointGeo, jointMat.clone());
    this.rIndexObj = new THREE.Mesh(jointGeo, jointMat.clone());
    scene.add(this.lThumbObj, this.lIndexObj, this.rThumbObj, this.rIndexObj);
    const pinchGeo = new THREE.SphereGeometry(PINCH_RADIUS, 16, 16);
    const lMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
    const rMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
    this.lPinchSphere = new THREE.Mesh(pinchGeo, lMat);
    this.rPinchSphere = new THREE.Mesh(pinchGeo, rMat);
    scene.add(this.lPinchSphere, this.rPinchSphere);
    this.lPinchSphere.visible = false;
    this.rPinchSphere.visible = false;
    this.hand1 = renderer.xr.getHand(0); 
    this.hand2 = renderer.xr.getHand(1); 
    scene.add(this.hand1);
    scene.add(this.hand2);
    this.lPinchOn = false;
    this.rPinchOn = false;
    this.leftHandRotationActive = false;
    this.rightHandRotationActive = false;
    this.lastLeftHandX = 0;
    this.lastRightHandX = 0;
    this.chairRotationSpeed = 5.0;
    this.onRotateChair = null;
    this._tmp = new THREE.Vector3();
  }
  _getAvailableHands() {
    const hands = [];
    if (this.hand1 && this.hand1.joints) hands.push(this.hand1);
    if (this.hand2 && this.hand2.joints) hands.push(this.hand2);
    return hands;
  }
  update(delta, opts = {}) {
    const { chairModel } = opts;
    const availableHands = this._getAvailableHands();
    const leftHand = availableHands[0] || null;
    const rightHand = availableHands[1] || availableHands[0] || null;
    this.lPinchSphere.visible = false;
    this.rPinchSphere.visible = false;
    if (leftHand && leftHand.joints) {
      const thumb = leftHand.joints['thumb-tip'];
      const index = leftHand.joints['index-finger-tip'];
      if (thumb) this.lThumbObj.position.copy(thumb.position);
      if (index) this.lIndexObj.position.copy(index.position);
    }
    if (rightHand && rightHand.joints) {
      const thumb = rightHand.joints['thumb-tip'];
      const index = rightHand.joints['index-finger-tip'];
      if (thumb) this.rThumbObj.position.copy(thumb.position);
      if (index) this.rIndexObj.position.copy(index.position);
    }
    this.lPinchOn = false;
    this.rPinchOn = false;
    if (
      leftHand &&
      leftHand.joints &&
      leftHand.joints['thumb-tip'] &&
      leftHand.joints['index-finger-tip']
    ) {
      const thumb = leftHand.joints['thumb-tip'];
      const index = leftHand.joints['index-finger-tip'];
      const dist = index.position.distanceTo(thumb.position);
      if (dist < PINCH_THRESHOLD) {
        this.lPinchOn = true;
        this.lPinchSphere.position.copy(thumb.position);
      }
    }
    if (
      rightHand &&
      rightHand.joints &&
      rightHand.joints['thumb-tip'] &&
      rightHand.joints['index-finger-tip']
    ) {
      const thumb = rightHand.joints['thumb-tip'];
      const index = rightHand.joints['index-finger-tip'];
      const dist = index.position.distanceTo(thumb.position);
      if (dist < PINCH_THRESHOLD) {
        this.rPinchOn = true;
        this.rPinchSphere.position.copy(thumb.position);
      }
    }
    if (chairModel && this.onRotateChair) {
      if (this.lPinchOn && leftHand && leftHand.joints['thumb-tip']) {
        const x = leftHand.joints['thumb-tip'].position.x;
        if (!this.leftHandRotationActive) {
          this.leftHandRotationActive = true;
          this.lastLeftHandX = x;
        } else {
          const dx = x - this.lastLeftHandX;
          if (Math.abs(dx) > 0.001) {
            this.onRotateChair(dx * this.chairRotationSpeed);
          }
          this.lastLeftHandX = x;
        }
      } else {
        this.leftHandRotationActive = false;
      }
      if (
        availableHands.length > 1 &&
        this.rPinchOn &&
        rightHand &&
        rightHand.joints['thumb-tip']
      ) {
        const x = rightHand.joints['thumb-tip'].position.x;
        if (!this.rightHandRotationActive) {
          this.rightHandRotationActive = true;
          this.lastRightHandX = x;
        } else {
          const dx = x - this.lastRightHandX;
          if (Math.abs(dx) > 0.001) {
            this.onRotateChair(dx * this.chairRotationSpeed);
          }
          this.lastRightHandX = x;
        }
      } else {
        this.rightHandRotationActive = false;
      }
    }
  }
}

====== CONTENT OF: chair\src\main.js ======
import * as THREE from 'three';
import gsap from 'gsap';
import { setupXR, attachXRSessionCallbacks } from './XRSetup.js';
import { HandInput } from './HandInput.js';
import { ChairExperience } from './ChairExperience.js';
gsap.ticker.lagSmoothing(0);
gsap.ticker.fps(60);
const { scene, camera, renderer } = setupXR();
const handInput = new HandInput(renderer, scene);
const experience = new ChairExperience(scene, camera, renderer, handInput);
experience.initLights();
experience.initBaseComposition();
experience.setupEnvMap(); 
experience.loadModelsAndUI().then(() => {
  console.log('Chair & UI ready');
});
attachXRSessionCallbacks(renderer, {
  onSessionStart: () => experience.onSessionStart(),
  onSessionEnd: () => experience.onSessionEnd()
});
const clock = new THREE.Clock();
renderer.setAnimationLoop((t, xrFrame) => {
  const delta = clock.getDelta();
  gsap.ticker.tick(delta);
  experience.update(delta, t);
  renderer.render(scene, camera);
});

====== CONTENT OF: chair\src\Shaders.js ======
import * as THREE from 'three';
let fresnelVertexShader = '';
let fresnelFragmentShader = '';
let fresnelMaterial = null;
let fresnelLoadFailed = false;
let sizesVertexShader = '';
let sizesFragmentShader = '';
let sizesMaterial = null;
let sizesLoadFailed = false;
export function preloadFresnelShaders() {
  if (fresnelVertexShader && fresnelFragmentShader) return Promise.resolve();
  if (fresnelLoadFailed) return Promise.reject(new Error('Fresnel shader load previously failed.'));
  const vPromise = fetch('/static/shaders/fresnel_vertex.glsl')
    .then(r => r.text())
    .then(src => {
      fresnelVertexShader = src;
    });
  const fPromise = fetch('/static/shaders/fresnel_fragment.glsl')
    .then(r => r.text())
    .then(src => {
      fresnelFragmentShader = src;
    });
  return Promise.all([vPromise, fPromise])
    .then(() => undefined)
    .catch(err => {
      fresnelLoadFailed = true;
      console.error('Failed to load Fresnel shaders:', err);
      throw err;
    });
}
export function preloadSizesShaders() {
  if (sizesVertexShader && sizesFragmentShader) return Promise.resolve();
  if (sizesLoadFailed) return Promise.reject(new Error('Sizes shader load previously failed.'));
  const vPromise = fetch('/static/shaders/sizes_vertex.glsl')
    .then(r => r.text())
    .then(src => {
      sizesVertexShader = src;
    });
  const fPromise = fetch('/static/shaders/sizes_fragment.glsl')
    .then(r => r.text())
    .then(src => {
      sizesFragmentShader = src;
    });
  return Promise.all([vPromise, fPromise])
    .then(() => undefined)
    .catch(err => {
      sizesLoadFailed = true;
      console.error('Failed to load Sizes shaders:', err);
      throw err;
    });
}
export function getOrCreateFresnelMaterial() {
  if (!fresnelMaterial) {
    fresnelMaterial = new THREE.ShaderMaterial({
      vertexShader: fresnelVertexShader,
      fragmentShader: fresnelFragmentShader,
      uniforms: {
        outlineThickness: { value: 2.0 },
        outlineColor: { value: new THREE.Color(0xffff00) }
      },
      side: THREE.FrontSide,
      transparent: true,
      depthTest: true,
      depthWrite: true
    });
  }
  return fresnelMaterial;
}
export function getOrCreateSizesMaterial() {
  if (!sizesMaterial) {
    sizesMaterial = new THREE.ShaderMaterial({
      vertexShader: sizesVertexShader,
      fragmentShader: sizesFragmentShader,
      uniforms: {
        baseColor: { value: new THREE.Color(0xffffff) },
        opacity: { value: 0.8 }
      },
      side: THREE.DoubleSide,
      transparent: true,
      depthTest: false,
      depthWrite: false
    });
  }
  return sizesMaterial;
}
function storeOriginalMaterialsIfMissing(mesh) {
  if (!mesh || !mesh.isMesh) return;
  if (!mesh.userData) mesh.userData = {};
  if (mesh.userData.originalMaterialStored) return;
  mesh.userData.originalMaterial = Array.isArray(mesh.material)
    ? mesh.material.slice()
    : mesh.material;
  mesh.userData.originalMaterialStored = true;
}
export function applyFresnelToChair(chairModel) {
  if (!chairModel) return;
  if (fresnelLoadFailed) {
    return;
  }
  if (!fresnelVertexShader || !fresnelFragmentShader) {
    preloadFresnelShaders()
      .then(() => applyFresnelToChair(chairModel))
      .catch(() => {
      });
    return;
  }
  const sharedFresnel = getOrCreateFresnelMaterial();
  chairModel.traverse(child => {
    if (child.isMesh && child.material && child.userData?.isOriginalChair) {
      storeOriginalMaterialsIfMissing(child);
      if (Array.isArray(child.material)) {
        for (let i = 0; i < child.material.length; i++) {
          child.material[i] = sharedFresnel;
        }
      } else {
        child.material = sharedFresnel;
      }
      child.material.needsUpdate = true;
    }
  });
}
export function restoreOriginalMaterials(chairModel) {
  if (!chairModel) return;
  chairModel.traverse(child => {
    if (
      child.isMesh &&
      child.userData &&
      child.userData.originalMaterialStored &&
      child.userData.isOriginalChair
    ) {
      child.material = child.userData.originalMaterial;
      if (Array.isArray(child.material)) {
        child.material.forEach(m => {
          if (m) m.needsUpdate = true;
        });
      } else if (child.material) {
        child.material.needsUpdate = true;
      }
    }
  });
}
export function updateSizesMaterialProperties(properties) {
  if (!sizesMaterial) return;
  if (properties.baseColor !== undefined) {
    sizesMaterial.uniforms.baseColor.value.setHex(properties.baseColor);
  }
  if (properties.opacity !== undefined) {
    sizesMaterial.uniforms.opacity.value = properties.opacity;
  }
  sizesMaterial.needsUpdate = true;
}

====== CONTENT OF: chair\src\style.css ======
.webgl
{
    position: fixed;
    top: 0;
    left: 0
}
html, 
body 
{
    overflow: hidden;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}
/* Add a click instruction overlay */
body::before {
    content: "Start WebXR";
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #ffff00;
    color: #000;
    padding: 20px 40px;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: 18px;
    font-weight: bold;
    z-index: 1000;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
/* Hide instruction when in XR */
body.xr-presenting::before {
    opacity: 0;
}
/* Force-hide any default WebXR/VR/AR buttons that libraries/browsers may inject */
#VRButton,
#ARButton,
.vr-button,
.ar-button,
.webxr-button,
.xr-button,
button[aria-label="Enter VR"],
button[aria-label="Enter XR"],
button[aria-label="Enter AR"] {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
}

====== CONTENT OF: chair\src\UIPanels.js ======
import * as THREE from 'three';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
export function createUIPanels(baseComposition) {
  const textureLoader = new THREE.TextureLoader();
  const frameGeometry = new THREE.PlaneGeometry(0.4, 0.6);
  const uiFrameTexture = textureLoader.load('/static/ui_frame.png');
  const frameMaterial = new THREE.MeshBasicMaterial({
    map: uiFrameTexture,
    transparent: true,
    opacity: 0.4,
    side: THREE.FrontSide
  });
  const uiFrame = new THREE.Mesh(frameGeometry, frameMaterial);
  uiFrame.position.set(0, 0, 0);
  baseComposition.add(uiFrame);
  const headerToggleGeometry = new THREE.PlaneGeometry(0.38666, 0.0661);
  const uiHeaderTexture = textureLoader.load('/static/ui_header-toggle.png');
  const headerToggleMaterial = new THREE.MeshBasicMaterial({
    map: uiHeaderTexture,
    transparent: true,
    opacity: 1.0,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false
  });
  const headerToggle = new THREE.Mesh(headerToggleGeometry, headerToggleMaterial);
  headerToggle.position.set(0, 0.26, 0);
  headerToggle.scale.set(0, 0, 0); 
  baseComposition.add(headerToggle);
  const switchWidth = 0.38666 * 0.432;
  const switchHeight = (switchWidth * 44) / 145;
  const headerToggleSwitchGeometry = new THREE.PlaneGeometry(switchWidth, switchHeight);
  const uiHeaderSwitchTexture = textureLoader.load('/static/ui_header-toggle-switch.png');
  const headerToggleSwitchMaterial = new THREE.MeshBasicMaterial({
    map: uiHeaderSwitchTexture,
    transparent: true,
    opacity: 1.0,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false
  });
  const headerToggleSwitchMesh = new THREE.Mesh(
    headerToggleSwitchGeometry,
    headerToggleSwitchMaterial
  );
  const togglePosA = new THREE.Vector3(-0.1, 0, 0.001); 
  const togglePosB = new THREE.Vector3(0.05, 0, 0.001); 
  headerToggleSwitchMesh.position.copy(togglePosA);
  headerToggle.add(headerToggleSwitchMesh);
  let materialTextMesh = null;
  let sizesTextMesh = null;
  const fontLoader = new FontLoader();
  fontLoader.load('/static/fonts/helvetiker_regular.typeface.json', font => {
    const textDefaultMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.9
    });
    const textActiveMaterial = new THREE.MeshBasicMaterial({
      color: 0xffd700, 
      transparent: true,
      opacity: 0.9
    });
    const materialTextGeometry = new TextGeometry('Material', {
      font,
      size: 0.02,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    materialTextMesh = new THREE.Mesh(materialTextGeometry, textActiveMaterial); 
    materialTextGeometry.computeBoundingBox();
    materialTextMesh.position.set(togglePosA.x, togglePosA.y - 0.01, togglePosA.z + 0.002);
    materialTextMesh.position.x -= materialTextGeometry.boundingBox.max.x * 0.5;
    headerToggle.add(materialTextMesh);
    const sizesTextGeometry = new TextGeometry('Sizes', {
      font,
      size: 0.02,
      depth: 0,
      curveSegments: 12,
      bevelEnabled: false
    });
    sizesTextMesh = new THREE.Mesh(sizesTextGeometry, textDefaultMaterial); 
    sizesTextGeometry.computeBoundingBox();
    sizesTextMesh.position.set(togglePosB.x, togglePosB.y - 0.01, togglePosB.z + 0.002);
    sizesTextMesh.position.x -= sizesTextGeometry.boundingBox.max.x * 0.5;
    headerToggle.add(sizesTextMesh);
    materialTextMesh.userData = materialTextMesh.userData || {};
    sizesTextMesh.userData = sizesTextMesh.userData || {};
    materialTextMesh.userData.defaultMaterial = textDefaultMaterial;
    materialTextMesh.userData.activeMaterial = textActiveMaterial;
    sizesTextMesh.userData.defaultMaterial = textDefaultMaterial;
    sizesTextMesh.userData.activeMaterial = textActiveMaterial;
  });
  const colorPanelGeometry = new THREE.PlaneGeometry(0.091, 0.278);
  const colorPanelMaterial = new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0.0,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false
  });
  const colorPanel = new THREE.Mesh(colorPanelGeometry, colorPanelMaterial);
  colorPanel.position.set(-0.26, 0, 0.06);
  baseComposition.add(colorPanel);
  const button1Texture = textureLoader.load('/static/ui_button1.png');
  const button2Texture = textureLoader.load('/static/ui_button2.png');
  const button3Texture = textureLoader.load('/static/ui_button3.png');
  const buttonStrokeTexture = textureLoader.load('/static/ui_buttonstroke.png');
  function makeButton(texture, y) {
    const geo = new THREE.PlaneGeometry(0.06, 0.06);
    const mat = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true,
      opacity: 1.0,
      side: THREE.FrontSide,
      depthTest: false,
      depthWrite: false
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, y, 0);
    colorPanel.add(mesh);
    return mesh;
  }
  const button1Mesh = makeButton(button1Texture, 0.09);
  const button2Mesh = makeButton(button2Texture, 0.0);
  const button3Mesh = makeButton(button3Texture, -0.09);
  function makeStroke(y) {
    const geo = new THREE.PlaneGeometry(0.08, 0.08);
    const mat = new THREE.MeshBasicMaterial({
      map: buttonStrokeTexture,
      transparent: true,
      opacity: 1.0,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, y, -0.001);
    colorPanel.add(mesh);
    return mesh;
  }
  const buttonStroke1Mesh = makeStroke(0.09);
  buttonStroke1Mesh.scale.set(1, 1, 1); 
  const buttonStroke2Mesh = makeStroke(0.0);
  buttonStroke2Mesh.scale.set(0, 0, 0);
  const buttonStroke3Mesh = makeStroke(-0.09);
  buttonStroke3Mesh.scale.set(0, 0, 0);
  const infoPanelGeometry = new THREE.PlaneGeometry(0.25, 0.25);
  const uiInfoTexture = textureLoader.load('/static/ui_info.png');
  const infoPanelMaterial = new THREE.MeshBasicMaterial({
    map: uiInfoTexture,
    transparent: true,
    opacity: 1.0,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false
  });
  const infoPanel = new THREE.Mesh(infoPanelGeometry, infoPanelMaterial);
  infoPanel.position.set(0.2, -0.17, 0.16);
  baseComposition.add(infoPanel);
  const switchButtonGeo = new THREE.SphereGeometry(0.018, 32, 32);
  const switchButtonMat = new THREE.MeshBasicMaterial({
    color: 0xffd700
  });
  const switchButton = new THREE.Mesh(switchButtonGeo, switchButtonMat);
  switchButton.position.set(0.16, 0.26, 0.0);
  baseComposition.add(switchButton);
  const pullPlaneGeo = new THREE.PlaneGeometry(0.066, 0.0462);
  const uiPullTexture = textureLoader.load('/static/ui_pull.png');
  const pullPlaneMat = new THREE.MeshBasicMaterial({
    map: uiPullTexture,
    transparent: true,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false
  });
  const pullPlane = new THREE.Mesh(pullPlaneGeo, pullPlaneMat);
  pullPlane.position.set(0.16, 0.31, 0.01);
  baseComposition.add(pullPlane);
  const switchRoot = new THREE.Object3D();
  switchRoot.position.copy(switchButton.position);
  baseComposition.add(switchRoot);
  const switchDotGeo = new THREE.SphereGeometry(0.006, 32, 32);
  const switchDotMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    depthTest: false,
    depthWrite: false
  });
  const switchDot = new THREE.Mesh(switchDotGeo, switchDotMat);
  switchDot.position.set(0.16, 0.26, 0.0);
  baseComposition.add(switchDot);
  return {
    uiFrame,
    headerToggle,
    headerToggleSwitchMesh,
    togglePosA,
    togglePosB,
    materialTextMesh,
    sizesTextMesh,
    colorPanel,
    button1Mesh,
    button2Mesh,
    button3Mesh,
    buttonStroke1Mesh,
    buttonStroke2Mesh,
    buttonStroke3Mesh,
    infoPanel,
    switchButton,
    switchDot,
    pullPlane,
    switchRoot
  };
}

====== CONTENT OF: chair\src\XRSetup.js ======
import * as THREE from 'three';
import { XRButton } from 'three/addons/webxr/XRButton.js';
export function setupXR() {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  const camera = new THREE.PerspectiveCamera(
    50,
    window.innerWidth / window.innerHeight,
    0.1,
    50
  );
  camera.position.set(0, 1.6, 3);
  scene.add(camera);
  const renderer = new THREE.WebGLRenderer({
    antialias: false,
    stencil: false,
    depth: true,
    powerPreference: 'high-performance',
    alpha: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.4;
  document.body.appendChild(renderer.domElement);
  const xrButton = XRButton.createButton(renderer, {
    optionalFeatures: ['hand-tracking']
  });
  xrButton.style.display = 'none';
  ['VRButton', 'ARButton', 'XRButton'].forEach(id => {
    const el = document.getElementById(id);
    if (el && el.parentNode) el.parentNode.removeChild(el);
  });
  document.querySelectorAll(
    '.vr-button, .ar-button, .webxr-button, .xr-button, ' +
      'button[aria-label="Enter VR"], button[aria-label="Enter XR"], button[aria-label="Enter AR"]'
  ).forEach(el => {
    if (el && el.parentNode) el.parentNode.removeChild(el);
  });
  document.body.style.cursor = 'pointer';
  document.body.addEventListener('click', () => {
    xrButton.click();
  });
  document.body.style.transition = 'background-color 0.3s ease';
  document.body.addEventListener('mouseenter', () => {
    document.body.style.backgroundColor = 'rgba(0,0,0,0.1)';
  });
  document.body.addEventListener('mouseleave', () => {
    document.body.style.backgroundColor = '';
  });
  window.addEventListener('resize', () => {
    const width = window.innerWidth;
    const height = window.innerHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  });
  return { scene, camera, renderer };
}
export function attachXRSessionCallbacks(renderer, { onSessionStart, onSessionEnd } = {}) {
  renderer.xr.addEventListener('sessionstart', () => {
    onSessionStart && onSessionStart();
  });
  renderer.xr.addEventListener('sessionend', () => {
    onSessionEnd && onSessionEnd();
  });
}

====== CONTENT OF: glowcube\index.html ======
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Glow Cube Demo</title>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body>
    <canvas class ="webgl"> </canvas>
    <script type="module" src="./src/main.js"></script>
</body>
</html>

====== CONTENT OF: glowcube\vite.config.js ======
import glsl from 'vite-plugin-glsl'
export default {
    root: './',
    publicDir: './public/',
    base: './',
    server:
    {
        host: true, 
        open: !('SANDBOX_URL' in process.env || 'CODESANDBOX_HOST' in process.env) 
    },
    build:
    {
        outDir: './dist', 
        emptyOutDir: true, 
        sourcemap: true, 
        target: 'esnext'
    },
    plugins:
    [
        glsl()
    ]
}

====== CONTENT OF: glowcube\src\main.js ======
import * as THREE from 'three';
import { XRButton } from 'three/addons/webxr/XRButton.js';
import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
import CANNON from 'cannon';
import vertexShader from './assets/shaders/vertex.glsl';
import fragmentShader from './assets/shaders/fragment.glsl';
let renderer, scene, camera, clock;
let handLeft, handRight;
let rThumbObj, rIndexObj, lThumbObj, lIndexObj;
let rPinchSphere, lPinchSphere;
let lPinchOn = false;
let rPinchOn = false;
let scalingOn = false;
let tempCube, box, boxMaterial;
let world, cubeShape, cubeBody;
let previousTime = 0;
init();
renderer.setAnimationLoop(animate);
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 50);
  camera.position.set(0, 1.6, 3);
  scene.add(camera);
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(
    XRButton.createButton(renderer, {
      optionalFeatures: ['depth-sensing', 'hand-tracking']
    })
  );
  setupLights();
  setupJointReferences();
  setupPinchReferences();
  setupHands();
  setupPhysics();
  setupBoxMesh();
  setupTempCube();
  clock = new THREE.Clock();
  window.addEventListener('resize', onWindowResize, false);
}
function setupLights() {
  const ambientLight = new THREE.AmbientLight(0xffffff, 1);  
  scene.add(ambientLight);
}
function setupJointReferences() {
  const sphereGeom = new THREE.SphereGeometry(0.002, 32, 32);
  const invisibleRed = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    opacity: 0,
    transparent: true
  });
  rThumbObj = new THREE.Mesh(sphereGeom, invisibleRed);
  rIndexObj = new THREE.Mesh(sphereGeom, invisibleRed);
  lThumbObj = new THREE.Mesh(sphereGeom, invisibleRed);
  lIndexObj = new THREE.Mesh(sphereGeom, invisibleRed);
  scene.add(rThumbObj, rIndexObj, lThumbObj, lIndexObj);
}
function setupPinchReferences() {
  const pinchGeom = new THREE.SphereGeometry(0.006, 32, 32);
  const pinchMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  rPinchSphere = new THREE.Mesh(pinchGeom, pinchMat);
  lPinchSphere = new THREE.Mesh(pinchGeom, pinchMat);
  rPinchSphere.visible = false;
  lPinchSphere.visible = false;
  scene.add(rPinchSphere, lPinchSphere);
}
function setupHands() {
  const handModelFactory = new XRHandModelFactory();
  handRight = renderer.xr.getHand(0);
  handLeft = renderer.xr.getHand(1);
}
function setupPhysics() {
  world = new CANNON.World();
  world.gravity.set(0, -9.82, 0);
  const defaultMaterial = new CANNON.Material('default');
  const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
    friction: 0.1,
    restitution: 0.7
  });
  world.addContactMaterial(defaultContactMaterial);
  world.defaultContactMaterial = defaultContactMaterial;
  cubeShape = new CANNON.Box(new CANNON.Vec3(0.2 * 0.5, 0.2 * 0.5, 0.2 * 0.5));
  cubeBody = new CANNON.Body({
    mass: 1,
    position: new CANNON.Vec3(0, 1.5, -0.5),
    shape: cubeShape
  });
  world.addBody(cubeBody);
  const floorShape = new CANNON.Plane();
  const floorBody = new CANNON.Body({ mass: 0 });
  floorBody.addShape(floorShape);
  floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(-1, 0, 0), Math.PI * 0.5);
  floorBody.position.y = 0.01;
  world.addBody(floorBody);
}
function setupBoxMesh() {
  const boxGeom = new THREE.BoxGeometry(0.2, 0.2, 0.2);
  boxMaterial = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    depthTest: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
      uTime: { value: 0 },
      resolution: { value: new THREE.Vector2(1800.0, 1800.0) }
    }
  });
  box = new THREE.Mesh(boxGeom, boxMaterial);
  box.castShadow = true;
  box.position.set(0, 1.5, -0.5);
  scene.add(box);
}
function setupTempCube() {
  const cubeGeom = new THREE.BoxGeometry(0.05, 0.05, 0.05);
  tempCube = new THREE.Mesh(cubeGeom, boxMaterial);
  tempCube.visible = false;
  scene.add(tempCube);
}
function animate() {
  const elapsedTime = clock.getElapsedTime();
  const deltaTime = elapsedTime - previousTime;
  previousTime = elapsedTime;
  world.step(1 / 60, deltaTime, 3);
  box.position.copy(cubeBody.position);
  box.quaternion.copy(cubeBody.quaternion);
  boxMaterial.uniforms.uTime.value = elapsedTime;
  updateJointReferences();
  updatePinchState();
  handleScalingLogic();
  renderer.render(scene, camera);
}
function updateJointReferences() {
  if (handRight?.joints) {
    const thumb = handRight.joints['thumb-tip'];
    const index = handRight.joints['index-finger-tip'];
    if (thumb) rThumbObj.position.copy(thumb.position);
    if (index) rIndexObj.position.copy(index.position);
  }
  if (handLeft?.joints) {
    const thumb = handLeft.joints['thumb-tip'];
    const index = handLeft.joints['index-finger-tip'];
    if (thumb) lThumbObj.position.copy(thumb.position);
    if (index) lIndexObj.position.copy(index.position);
  }
}
function updatePinchState() {
  const rDist = rIndexObj.position.distanceTo(rThumbObj.position);
  const lDist = lIndexObj.position.distanceTo(lThumbObj.position);
  if (rDist < 0.02) {
    rPinchSphere.position.copy(rThumbObj.position);
    rPinchOn = true;
  } else {
    rPinchOn = false;
    rPinchSphere.visible = false;
  }
  if (lDist < 0.02) {
    lPinchSphere.position.copy(lThumbObj.position);
    lPinchOn = true;
  } else {
    lPinchOn = false;
    lPinchSphere.visible = false;
  }
}
function handleScalingLogic() {
  if (lPinchOn && rPinchOn) {
    if (!scalingOn) {
      tempCube.visible = true;
      scalingOn = true;
    }
    cubeScaling();
  } else {
    if (scalingOn) {
      spawnCube();
      tempCube.visible = false;
      scalingOn = false;
    }
  }
}
function spawnCube() {
  cubeScaling(); 
  cubeBody.position.set(tempCube.position.x, tempCube.position.y, tempCube.position.z);
  cubeBody.quaternion.set(
    tempCube.quaternion.x,
    tempCube.quaternion.y,
    tempCube.quaternion.z,
    tempCube.quaternion.w ?? cubeBody.quaternion.w
  );
  box.scale.set(tempCube.scale.x * 0.25, tempCube.scale.y * 0.25, tempCube.scale.z * 0.25);
  const newHalfExtents = new CANNON.Vec3(
    box.scale.x * 0.125,
    box.scale.y * 0.125,
    box.scale.z * 0.125
  );
  cubeShape.halfExtents = newHalfExtents;
  cubeShape.updateConvexPolyhedronRepresentation();
}
function cubeScaling() {
  const midPoint = new THREE.Vector3()
    .addVectors(rPinchSphere.position, lPinchSphere.position)
    .divideScalar(2);
  const targetDir = new THREE.Vector3()
    .subVectors(rPinchSphere.position, lPinchSphere.position)
    .normalize();
  tempCube.position.copy(midPoint);
  tempCube.lookAt(new THREE.Vector3().addVectors(tempCube.position, targetDir));
  const pointDist = rPinchSphere.position.distanceTo(lPinchSphere.position);
  const scaleValue = THREE.MathUtils.mapLinear(pointDist, 0, 0.1, 0, 1);
  tempCube.scale.set(scaleValue, scaleValue, scaleValue);
}
function onWindowResize() {
  if (!camera || !renderer) return;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

====== CONTENT OF: glowcube\src\style.css ======
.webgl
{
    position: fixed;
    top: 0;
    left: 0
}
html, 
body 
{
    overflow: hidden
}

====== CONTENT OF: glowcube\src\assets\shaders\fragment.glsl ======
varying vec2 vUv;
uniform float uTime;
vec3 palette( float t )
{
    vec3 a = vec3(0.938, 0.328, 0.718);
    vec3 b = vec3(0.659, 0.438, 0.328);
    vec3 c = vec3(0.388, 0.388, 0.296);
    vec3 d = vec3(2.538, 2.478, 0.168);
    return a + b*cos( 6.28318*(c*t+d) );
}
void main() {
    vec2 mUv = vec2(vUv.x - 0.5, vUv.y - 0.5);
    float d = length(mUv);
    vec3 col = palette(d + uTime);
    d = sin(d * 8.0 + uTime) / 8.0;
    d = abs(d);
    d = 0.02 / d;
    col *= d;
    gl_FragColor = vec4(col, 1.0);
}

====== CONTENT OF: glowcube\src\assets\shaders\vertex.glsl ======
varying vec2 vUv;
void main()
{
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vUv = uv;
}

====== CONTENT OF: sneaker\index.html ======
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Sneaker Demo</title>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body>
    <canvas class ="webgl"> </canvas>
    <script type="module" src="./src/main.js"></script>
</body>
</html>

====== CONTENT OF: sneaker\vite.config.js ======
import glsl from 'vite-plugin-glsl'
export default {
    root: './',
    publicDir: './public/',
    base: './',
    server:
    {
        host: true, 
        open: !('SANDBOX_URL' in process.env || 'CODESANDBOX_HOST' in process.env) 
    },
    build:
    {
        outDir: './dist', 
        emptyOutDir: true, 
        sourcemap: true 
    },
    plugins:
    [
        glsl()
    ]
}

====== CONTENT OF: sneaker\src\Environment.js ======
import * as THREE from 'three';
import { HDRLoader } from 'three/examples/jsm/loaders/HDRLoader.js';
export class Environment {
    constructor(scene, pmrem) {
        this.scene = scene;
        this.pmrem = pmrem;
        this.setupHDRI();
        this.setupLights();
    }
    setupHDRI() {
        const hdrLoader = new HDRLoader();
        hdrLoader.load('/static/2k.hdr', (hdrTexture) => {
            const envRT = this.pmrem.fromEquirectangular(hdrTexture);
            this.scene.environment = envRT.texture;
            hdrTexture.dispose();
            this.pmrem.dispose();
        });
    }
    setupLights() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        this.scene.add(ambientLight);
        const keyLight = new THREE.DirectionalLight(0xfff4e6, 2.0);
        keyLight.position.set(5, 10, 5);
        keyLight.castShadow = false;
        this.scene.add(keyLight);
        const fillLight = new THREE.DirectionalLight(0xe6f3ff, 1.2);
        fillLight.position.set(-5, 8, -5);
        this.scene.add(fillLight);
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.8);
        rimLight.position.set(0, 5, -10);
        this.scene.add(rimLight);
        const pointLight = new THREE.PointLight(0xffffff, 1.5, 20);
        pointLight.position.set(0, 6, 3);
        pointLight.castShadow = false;
        this.scene.add(pointLight);
    }
}

====== CONTENT OF: sneaker\src\HandInput.js ======
import * as THREE from 'three';
import gsap from 'gsap';
export class HandInput {
    constructor(scene, renderer, camera) {
        this.scene = scene;
        this.renderer = renderer;
        this.camera = camera;
        this.lPinchOn = false;
        this.rPinchOn = false;
        this.leftPinchPrimed = false;
        this.rightPinchPrimed = false;
        this.leftHandRotationActive = false;
        this.rightHandRotationActive = false;
        this.lastRightHandX = 0;
        this.lastLeftHandX = 0;
        this.lastRightHandY = 0;
        this.lastLeftHandY = 0;
        this.leftHandGrabbing = false;
        this.rightHandGrabbing = false;
        this.grabbedObject = null;
        this.originalParent = null;
        this.originalPosition = null;
        this.originalRotation = null;
        this.grabDistance = 0.15;
        this.grabOffset = 0.05;
        this.isAnimatingBack = false;
        this.XR_START_GRACE_MS = 1000;
        this.xrInteractionBlockedUntil = 0;
        this.userMovedShoeThisSession = false;
        this.SNAP_BACK_ON_RELEASE = true;
        this.PINCH_START = 0.018;
        this.PINCH_END = 0.028;
        this.initJointReferences();
        this.initPinchReferences();
        this.initHands();
        this.renderer.xr.addEventListener('sessionstart', () => this.onSessionStart());
        this.renderer.xr.addEventListener('sessionend', () => this.onSessionEnd());
    }
    initJointReferences() {
        const sphere = new THREE.SphereGeometry(0.002, 32, 32);
        const defaultMat = new THREE.MeshBasicMaterial({ 
            color: 0xff0000, 
            opacity: 0,
            transparent: true 
        });
        this.lThumbObj = new THREE.Mesh(sphere, defaultMat);
        this.lIndexObj = new THREE.Mesh(sphere, defaultMat);
        this.rThumbObj = new THREE.Mesh(sphere, defaultMat);
        this.rIndexObj = new THREE.Mesh(sphere, defaultMat);
        this.scene.add(this.lThumbObj);
        this.scene.add(this.lIndexObj);
        this.scene.add(this.rThumbObj);
        this.scene.add(this.rIndexObj);
    }
    initPinchReferences() {
        const sphere2 = new THREE.SphereGeometry(0.006, 32, 32);
        const defaultMat2 = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const greenMat2 = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
        this.lPinchSphere = new THREE.Mesh(sphere2, defaultMat2);
        this.rPinchSphere = new THREE.Mesh(sphere2, greenMat2);
        this.scene.add(this.lPinchSphere);
        this.scene.add(this.rPinchSphere);
        this.lPinchSphere.material.transparent = true;
        this.lPinchSphere.material.opacity = 0.0;
        this.rPinchSphere.material.transparent = true;
        this.rPinchSphere.material.opacity = 0.0;
    }
    initHands() {
        this.hand1 = this.renderer.xr.getHand(0);
        this.scene.add(this.hand1);
        this.hand2 = this.renderer.xr.getHand(1);
        this.scene.add(this.hand2);
        this.handsGroup = new THREE.Group();
        this.handsGroup.add(this.hand1, this.hand2);
        this.scene.add(this.handsGroup);
        this.handsGroup.visible = false;
    }
    onSessionStart() {
        this.xrInteractionBlockedUntil = Date.now() + this.XR_START_GRACE_MS;
        this.leftPinchPrimed = false;
        this.rightPinchPrimed = false;
        this.userMovedShoeThisSession = false;
        this.resetGrabAndPinchState();
    }
    onSessionEnd() {
        this.xrInteractionBlockedUntil = 0;
        this.leftPinchPrimed = false;
        this.rightPinchPrimed = false;
    }
    isJointTracked(j) {
        return !!j && Number.isFinite(j.position?.x) && 
               Number.isFinite(j.position?.y) && 
               Number.isFinite(j.position?.z) && 
               j.visible !== false;
    }
    resetGrabAndPinchState(productModel, objectsParent, sizeScales, selectedSizeIndex) {
        this.lPinchOn = false;
        this.rPinchOn = false;
        this.leftHandRotationActive = false;
        this.rightHandRotationActive = false;
        if (productModel && objectsParent) {
            const currentParent = productModel.parent;
            if (currentParent === this.lPinchSphere || currentParent === this.rPinchSphere) {
                objectsParent.add(productModel);
                productModel.position.set(0, 0.03, 0);
                productModel.rotation.set(0, 0, 0);
                const currentScale = sizeScales[selectedSizeIndex] || 1.0;
                productModel.scale.set(currentScale, currentScale, currentScale);
            }
        }
        this.leftHandGrabbing = false;
        this.rightHandGrabbing = false;
        this.grabbedObject = null;
        this.originalParent = null;
        this.originalPosition = null;
        this.originalRotation = null;
        this.isAnimatingBack = false;
    }
    dropGrabbedObjectInPlace(obj, targetParent) {
        if (!obj || !targetParent) return;
        obj.updateMatrixWorld(true);
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        obj.getWorldPosition(worldPos);
        obj.getWorldQuaternion(worldQuat);
        targetParent.add(obj);
        targetParent.worldToLocal(worldPos);
        const parentWorldQuat = targetParent.getWorldQuaternion(new THREE.Quaternion());
        const localQuat = worldQuat.clone().multiply(parentWorldQuat.invert());
        obj.position.copy(worldPos);
        obj.quaternion.copy(localQuat);
    }
    update(context) {
        if (this.xrInteractionBlockedUntil && Date.now() < this.xrInteractionBlockedUntil) {
            return;
        }
        const leftHand = this.hand1;
        const rightHand = this.hand2;
        this.updateJointPositions(leftHand, rightHand);
        this.handleLeftHandPinch(leftHand, context);
        this.handleRightHandPinch(rightHand, context);
    }
    updateJointPositions(leftHand, rightHand) {
        if (leftHand && leftHand.joints && leftHand.joints['thumb-tip']) {
            const thumbTip = leftHand.joints['thumb-tip'];
            this.lThumbObj.position.copy(thumbTip.position);
            this.lThumbObj.rotation.copy(thumbTip.rotation);
        }
        if (leftHand && leftHand.joints && leftHand.joints['index-finger-tip']) {
            const indexTip = leftHand.joints['index-finger-tip'];
            this.lIndexObj.position.copy(indexTip.position);
            this.lIndexObj.rotation.copy(indexTip.rotation);
        }
        if (rightHand && rightHand.joints && rightHand.joints['thumb-tip']) {
            const thumbTip = rightHand.joints['thumb-tip'];
            this.rThumbObj.position.copy(thumbTip.position);
            this.rThumbObj.rotation.copy(thumbTip.rotation);
        }
        if (rightHand && rightHand.joints && rightHand.joints['index-finger-tip']) {
            const indexTip = rightHand.joints['index-finger-tip'];
            this.rIndexObj.position.copy(indexTip.position);
            this.rIndexObj.rotation.copy(indexTip.rotation);
        }
    }
    handleLeftHandPinch(leftHand, context) {
        const { productModel, objectsParent, rotationSpeed, 
                currentObjectType, cloudModel, colorCircleDot } = context;
        const lTracked = this.isJointTracked(leftHand?.joints?.['thumb-tip']) && 
                        this.isJointTracked(leftHand?.joints?.['index-finger-tip']);
        const lIndexThumbDist = lTracked ? 
            this.lIndexObj.position.distanceTo(this.lThumbObj.position) : Infinity;
        if (!this.lPinchOn && lIndexThumbDist < this.PINCH_START) this.lPinchOn = true;
        if (this.lPinchOn && lIndexThumbDist > this.PINCH_END) this.lPinchOn = false;
        if (lIndexThumbDist > this.PINCH_END) this.leftPinchPrimed = true;
        const leftActionablePinch = lTracked && this.leftPinchPrimed && this.lPinchOn;
        if (leftActionablePinch) {
            this.lPinchSphere.position.copy(this.lThumbObj.position);
            this.lPinchSphere.rotation.copy(this.lThumbObj.rotation);
            if (!this.leftHandGrabbing && !this.rightHandGrabbing && 
                !this.isAnimatingBack && !colorCircleDot.userData.isDragging) {
                if (productModel && productModel.visible) {
                    const cubeWorldPosition = new THREE.Vector3();
                    productModel.getWorldPosition(cubeWorldPosition);
                    const distanceToCube = this.lPinchSphere.position.distanceTo(cubeWorldPosition);
                    if (distanceToCube < this.grabDistance) {
                        this.startGrabbing('left', productModel, context);
                    }
                }
            }
            if ((this.leftHandGrabbing && this.grabbedObject) || colorCircleDot.userData.isDragging) {
                this.leftHandRotationActive = false;
            } else if (!this.leftHandGrabbing) {
                this.handleRotation('left', context);
            }
        } else {
            if (this.leftHandGrabbing && this.grabbedObject) {
                this.releaseGrabbedObject(objectsParent);
            }
            if (this.leftHandRotationActive) {
                this.leftHandRotationActive = false;
            }
        }
    }
    handleRightHandPinch(rightHand, context) {
        const { productModel, objectsParent, rotationSpeed, 
                currentObjectType, cloudModel, colorCircleDot } = context;
        const rTracked = this.isJointTracked(rightHand?.joints?.['thumb-tip']) && 
                        this.isJointTracked(rightHand?.joints?.['index-finger-tip']);
        const rIndexThumbDist = rTracked ? 
            this.rIndexObj.position.distanceTo(this.rThumbObj.position) : Infinity;
        if (!this.rPinchOn && rIndexThumbDist < this.PINCH_START) this.rPinchOn = true;
        if (this.rPinchOn && rIndexThumbDist > this.PINCH_END) this.rPinchOn = false;
        if (rIndexThumbDist > this.PINCH_END) this.rightPinchPrimed = true;
        const rightActionablePinch = rTracked && this.rightPinchPrimed && this.rPinchOn;
        if (rightActionablePinch) {
            this.rPinchSphere.position.copy(this.rThumbObj.position);
            this.rPinchSphere.rotation.copy(this.rThumbObj.rotation);
            if (!this.leftHandGrabbing && !this.rightHandGrabbing && 
                !this.isAnimatingBack && !colorCircleDot.userData.isDragging) {
                if (productModel && productModel.visible) {
                    const cubeWorldPosition = new THREE.Vector3();
                    productModel.getWorldPosition(cubeWorldPosition);
                    const distanceToCube = this.rPinchSphere.position.distanceTo(cubeWorldPosition);
                    if (distanceToCube < this.grabDistance) {
                        this.startGrabbing('right', productModel, context);
                    }
                }
            }
            if ((this.rightHandGrabbing && this.grabbedObject) || colorCircleDot.userData.isDragging) {
                this.rightHandRotationActive = false;
            } else if (!this.rightHandGrabbing) {
                this.handleRotation('right', context);
            }
        } else {
            if (this.rightHandGrabbing && this.grabbedObject) {
                this.releaseGrabbedObject(objectsParent);
            }
            if (this.rightHandRotationActive) {
                this.rightHandRotationActive = false;
            }
        }
    }
    startGrabbing(hand, productModel, context) {
        const { colorCircleOpen, colorCircleOrigin, closeButtonPlane } = context;
        if (hand === 'left') {
            this.leftHandGrabbing = true;
        } else {
            this.rightHandGrabbing = true;
        }
        this.grabbedObject = productModel;
        this.originalParent = productModel.parent;
        this.originalPosition = productModel.position.clone();
        this.originalRotation = productModel.rotation.clone();
        if (colorCircleOpen && context.setColorCircleOpen) {
            context.setColorCircleOpen(false);
            gsap.to([colorCircleOrigin.scale, closeButtonPlane.scale], {
                x: 0, y: 0, z: 0,
                duration: 0.3,
                ease: "power2.inOut"
            });
        }
        const worldQuaternion = productModel.getWorldQuaternion(new THREE.Quaternion());
        const pinchSphere = hand === 'left' ? this.lPinchSphere : this.rPinchSphere;
        pinchSphere.add(productModel);
        productModel.position.set(0, 0, -this.grabOffset);
        const parentWorldQuaternion = pinchSphere.getWorldQuaternion(new THREE.Quaternion());
        const localQuaternion = worldQuaternion.clone().multiply(parentWorldQuaternion.invert());
        productModel.quaternion.copy(localQuaternion);
        this.userMovedShoeThisSession = true;
    }
    releaseGrabbedObject(objectsParent) {
        if (this.leftHandGrabbing) this.leftHandGrabbing = false;
        if (this.rightHandGrabbing) this.rightHandGrabbing = false;
        if (this.SNAP_BACK_ON_RELEASE) {
            if (!this.isAnimatingBack) {
                this.isAnimatingBack = true;
                const currentWorldPosition = new THREE.Vector3();
                this.grabbedObject.getWorldPosition(currentWorldPosition);
                this.originalParent.add(this.grabbedObject);
                const localPosition = new THREE.Vector3();
                localPosition.copy(currentWorldPosition);
                this.originalParent.worldToLocal(localPosition);
                this.grabbedObject.position.copy(localPosition);
                gsap.to(this.grabbedObject.position, {
                    x: this.originalPosition.x,
                    y: this.originalPosition.y,
                    z: this.originalPosition.z,
                    duration: 1.0,
                    ease: "elastic.out(0.7, 0.5)",
                    onComplete: () => {
                        this.isAnimatingBack = false;
                    }
                });
                gsap.to(this.grabbedObject.rotation, {
                    x: this.originalRotation.x,
                    y: this.originalRotation.y,
                    z: this.originalRotation.z,
                    duration: 1.0,
                    ease: "elastic.out(0.7, 0.5)"
                });
            }
        } else {
            this.dropGrabbedObjectInPlace(this.grabbedObject, objectsParent);
        }
        this.grabbedObject = null;
        this.originalParent = null;
        this.originalPosition = null;
        this.originalRotation = null;
    }
    handleRotation(hand, context) {
        const { productModel, cloudModel, currentObjectType, rotationSpeed, 
                shoeRotation, cloudRotation } = context;
        const isLeft = hand === 'left';
        const thumbObj = isLeft ? this.lThumbObj : this.rThumbObj;
        if (isLeft) {
            if (!this.leftHandRotationActive) {
                this.leftHandRotationActive = true;
                this.lastLeftHandX = thumbObj.position.x;
                this.lastLeftHandY = thumbObj.position.y;
            }
            if (this.leftHandRotationActive) {
                const currentX = thumbObj.position.x;
                const currentY = thumbObj.position.y;
                const deltaX = currentX - this.lastLeftHandX;
                const deltaY = currentY - this.lastLeftHandY;
                this.applyRotation(deltaX, deltaY, context);
                this.lastLeftHandX = currentX;
                this.lastLeftHandY = currentY;
            }
        } else {
            if (!this.rightHandRotationActive) {
                this.rightHandRotationActive = true;
                this.lastRightHandX = thumbObj.position.x;
                this.lastRightHandY = thumbObj.position.y;
            }
            if (this.rightHandRotationActive) {
                const currentX = thumbObj.position.x;
                const currentY = thumbObj.position.y;
                const deltaX = currentX - this.lastRightHandX;
                const deltaY = currentY - this.lastRightHandY;
                this.applyRotation(deltaX, deltaY, context);
                this.lastRightHandX = currentX;
                this.lastRightHandY = currentY;
            }
        }
    }
    applyRotation(deltaX, deltaY, context) {
        const { productModel, cloudModel, currentObjectType, rotationSpeed, 
                shoeRotation, cloudRotation } = context;
        if (Math.abs(deltaX) > 0.001) {
            if (currentObjectType === 'shoe' && productModel && productModel.visible) {
                shoeRotation.y += deltaX * rotationSpeed;
                productModel.rotation.y = shoeRotation.y;
            } else if (currentObjectType === 'cloud' && cloudModel && cloudModel.visible) {
                cloudRotation.y += deltaX * rotationSpeed;
                cloudModel.rotation.y = cloudRotation.y;
            }
        }
        if (Math.abs(deltaY) > 0.001 && currentObjectType === 'cloud' && 
            cloudModel && cloudModel.visible) {
            const newRotationX = cloudRotation.x - deltaY * rotationSpeed;
            const minRotation = -Math.PI / 3;
            const maxRotation = Math.PI / 3;
            cloudRotation.x = Math.max(minRotation, Math.min(maxRotation, newRotationX));
            cloudModel.rotation.x = cloudRotation.x;
        }
    }
}

====== CONTENT OF: sneaker\src\main.js ======
import * as THREE from 'three';
import gsap from 'gsap';
import { XRSetup } from './XRSetup.js';
import { HandInput } from './HandInput.js';
import { UIHeader } from './UIHeader.js';
import { UIColorPicker } from './UIColorPicker.js';
import { UITagsCloud } from './UITagsCloud.js';
import { Environment } from './Environment.js';
import { Models } from './Models.js';
gsap.ticker.lagSmoothing(0);
gsap.ticker.fps(60);
function configureTexture(texture) {
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.generateMipmaps = true;
    return texture;
}
const scene = new THREE.Scene();
const defaultBackground = new THREE.Color(0x000000);
scene.background = defaultBackground;
const canvas = document.querySelector('canvas.webgl');
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 50);
camera.position.set(0, 1.6, 3);
scene.add(camera);
const xrSetup = new XRSetup(scene, camera);
const renderer = xrSetup.getRenderer();
const pmrem = xrSetup.getPMREM();
const tempGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
const tempMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff, 
    transparent: true,
    opacity: 0.0,
    depthTest: false,
    depthWrite: false
});
const baseComposition = new THREE.Mesh(tempGeo, tempMat);
baseComposition.scale.set(0.9, 0.9, 0.9);
scene.add(baseComposition);
baseComposition.visible = false;
const objectsParent = new THREE.Group();
objectsParent.position.set(0, 0, 0);
objectsParent.rotation.set(0, 0, 0);
baseComposition.add(objectsParent);
const textureLoader = new THREE.TextureLoader();
const planeGeometry = new THREE.PlaneGeometry(0.4, 0.4);
const uiCircleTexture = configureTexture(textureLoader.load('/static/ui_circle.png'));
const planeMaterial = new THREE.MeshLambertMaterial({ 
    map: uiCircleTexture,
    transparent: true,
    opacity: 0.8,
    side: THREE.DoubleSide,
    toneMapped: false
});
const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
groundPlane.rotation.x = -Math.PI / 2;
groundPlane.position.set(0, -0.1, 0);
baseComposition.add(groundPlane);
const buttonGeometry = new THREE.PlaneGeometry(0.1517, 0.0525);
const buttonTexture = configureTexture(textureLoader.load('/static/ui_button-search.png'));
const buttonTextureEdit = configureTexture(textureLoader.load('/static/ui_button-search.png'));
const buttonTextureDone = configureTexture(textureLoader.load('/static/ui_button-done.png'));
const buttonMaterial = new THREE.MeshBasicMaterial({ 
    map: buttonTexture,
    transparent: true,
    opacity: 1.0,
    side: THREE.DoubleSide,
    toneMapped: false
});
const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
button.position.set(0, -0.18, 0.22);
button.rotation.x = -20 * Math.PI / 180;
baseComposition.add(button);
let isButtonPressed = false;
let buttonTouchActive = false;
let lastButtonTouchTime = 0;
const buttonTouchCooldown = 500;
function updateButtonTexture() {
    if (models.getCurrentObjectType() === 'shoe') {
        buttonMaterial.map = buttonTexture;
    } else {
        buttonMaterial.map = buttonTextureDone;
    }
    buttonMaterial.needsUpdate = true;
}
function animateButtonPress() {
    if (isButtonPressed) return;
    isButtonPressed = true;
    const originalScale = 1.0;
    gsap.to(button.scale, {
        x: originalScale * 0.7,
        y: originalScale * 0.7,
        z: originalScale * 0.7,
        duration: 0.12,
        ease: "power2.out",
        onComplete: () => {
            models.toggleShoeCloudVisibility({
                header: uiHeader.getHeader(),
                headerTags: uiTagsCloud.getHeaderTags(),
                groundPlane: groundPlane,
                colorPicker: uiColorPicker,
                cachedDotPlanes: uiTagsCloud.cachedDotPlanes
            });
            updateButtonTexture();
            gsap.to(button.scale, {
                x: originalScale,
                y: originalScale,
                z: originalScale,
                duration: 0.3,
                ease: "power2.out",
                onComplete: () => {
                    isButtonPressed = false;
                }
            });
        }
    });
}
const uiHeader = new UIHeader(baseComposition, textureLoader, configureTexture);
const uiColorPicker = new UIColorPicker(uiHeader.getHeader(), textureLoader, configureTexture);
const uiTagsCloud = new UITagsCloud(baseComposition, textureLoader, configureTexture, camera);
const environment = new Environment(scene, pmrem);
const models = new Models(objectsParent, uiHeader.getSizeScales(), uiHeader.getSelectedSizeIndex());
const handInput = new HandInput(scene, renderer, camera);
models.loadShoe(() => {
    uiColorPicker.setShoeColorLayer(models.getShoeColorLayer());
    renderer.xr.addEventListener('sessionstart', () => {
        baseComposition.visible = true;
        const productModel = models.getProductModel();
        if (productModel && !handInput.userMovedShoeThisSession) {
            gsap.killTweensOf(productModel.position);
            gsap.killTweensOf(productModel.rotation);
            gsap.killTweensOf(productModel.scale);
            productModel.position.set(0, 0.03, 0);
            productModel.rotation.set(0, 0, 0);
            const currentScale = uiHeader.getSizeScales()[uiHeader.getSelectedSizeIndex()] || 1.0;
            productModel.scale.set(currentScale, currentScale, currentScale);
        }
        handInput.resetGrabAndPinchState(
            productModel,
            objectsParent,
            uiHeader.getSizeScales(),
            uiHeader.getSelectedSizeIndex()
        );
    });
    renderer.xr.addEventListener('sessionend', () => {
        baseComposition.visible = false;
    });
});
models.loadCloud(() => {}, (cloudModel) => {
    uiTagsCloud.createDotPlanes(cloudModel);
});
updateButtonTexture();
const clock = new THREE.Clock();
xrSetup.setAnimationLoop(function() {
    const delta = clock.getDelta();
    gsap.ticker.tick(delta);
    xrSetup.render();
    const handContext = {
        productModel: models.getProductModel(),
        cloudModel: models.getCloudModel(),
        objectsParent: objectsParent,
        rotationSpeed: models.getRotationSpeed(),
        currentObjectType: models.getCurrentObjectType(),
        shoeRotation: models.getShoeRotation(),
        cloudRotation: models.getCloudRotation(),
        colorCircleDot: uiColorPicker.getColorCircleDot(),
        colorCircleOpen: uiColorPicker.isColorCircleOpen(),
        colorCircleOrigin: uiColorPicker.getColorCircleOrigin(),
        closeButtonPlane: uiColorPicker.getCloseButtonPlane(),
        setColorCircleOpen: (value) => uiColorPicker.setColorCircleOpen(value)
    };
    handInput.update(handContext);
    handleInteractions();
    uiTagsCloud.updateDotPlanesToFaceCamera(models.getCloudModel());
    if (!xrSetup.compositionPositioned) {
        xrSetup.positionCompositionAtHeadHeight(
            baseComposition,
            models.getProductModel(),
            uiHeader.getSizeScales(),
            uiHeader.getSelectedSizeIndex()
        );
    }
});
function handleInteractions() {
    const currentTime = Date.now();
    const lIndexObj = handInput.lIndexObj;
    const rIndexObj = handInput.rIndexObj;
    const buttonWorldPosition = new THREE.Vector3();
    button.getWorldPosition(buttonWorldPosition);
    if (lIndexObj && button) {
        const leftIndexToButton = lIndexObj.position.distanceTo(buttonWorldPosition);
        if (leftIndexToButton < 0.06 && !buttonTouchActive && 
            (currentTime - lastButtonTouchTime) > buttonTouchCooldown) {
            buttonTouchActive = true;
            lastButtonTouchTime = currentTime;
            animateButtonPress();
        }
    }
    if (rIndexObj && button) {
        const rightIndexToButton = rIndexObj.position.distanceTo(buttonWorldPosition);
        if (rightIndexToButton < 0.06 && !buttonTouchActive && 
            (currentTime - lastButtonTouchTime) > buttonTouchCooldown) {
            buttonTouchActive = false;
            lastButtonTouchTime = currentTime;
            animateButtonPress();
        }
    }
    if (lIndexObj && button && rIndexObj && button) {
        const leftIndexToButton = lIndexObj.position.distanceTo(buttonWorldPosition);
        const rightIndexToButton = rIndexObj.position.distanceTo(buttonWorldPosition);
        if (leftIndexToButton > 0.09 && rightIndexToButton > 0.09) {
            buttonTouchActive = false;
        }
    }
    const colorButtonPressed = uiColorPicker.handleColorButtonInteraction(
        lIndexObj,
        rIndexObj,
        currentTime,
        lastButtonTouchTime,
        buttonTouchCooldown
    );
    if (colorButtonPressed) {
        lastButtonTouchTime = currentTime;
    }
    uiColorPicker.handleColorCircleDotInteraction(
        handInput.lPinchOn,
        handInput.rPinchOn,
        handInput.lPinchSphere,
        handInput.rPinchSphere
    );
    const sizeResult = uiHeader.handleSizeButtonInteraction(
        lIndexObj,
        rIndexObj,
        models.getProductModel(),
        currentTime,
        lastButtonTouchTime,
        buttonTouchCooldown,
        buttonTouchActive,
        uiColorPicker.isColorCircleOpen()
    );
    if (sizeResult && sizeResult.shouldUpdateCooldown) {
        lastButtonTouchTime = currentTime;
        buttonTouchActive = true;
    }
    const tagResult = uiTagsCloud.handleTagInteraction(
        lIndexObj,
        rIndexObj,
        models.getCloudModel(),
        currentTime,
        lastButtonTouchTime,
        buttonTouchCooldown,
        buttonTouchActive
    );
    if (tagResult && tagResult.shouldUpdateCooldown) {
        lastButtonTouchTime = currentTime;
        buttonTouchActive = true;
    }
}

====== CONTENT OF: sneaker\src\Models.js ======
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import gsap from 'gsap';
export class Models {
    constructor(objectsParent, sizeScales, selectedSizeIndex) {
        this.objectsParent = objectsParent;
        this.sizeScales = sizeScales;
        this.selectedSizeIndex = selectedSizeIndex;
        this.loader = new GLTFLoader();
        this.productModel = null;
        this.cloudModel = null;
        this.shoeColorLayer = null;
        this.currentObjectType = 'shoe';
        this.shoeRotation = { x: 0, y: 0 };
        this.cloudRotation = { x: 0, y: 0 };
        this.rotationSpeed = 6.0;
    }
    loadShoe(onLoad) {
        this.loader.load('/static/product.glb', (gltf) => {
            this.productModel = gltf.scene;
            const initialScale = this.sizeScales[this.selectedSizeIndex] || 1.0;
            this.productModel.scale.set(initialScale, initialScale, initialScale);
            this.productModel.position.set(0, 0.03, 0);
            this.productModel.rotation.set(0, 0, 0);
            this.productModel.traverse((child) => {
                if (child.name === 'color' && child.isMesh) {
                    this.shoeColorLayer = child;
                    const shoeMaterial = new THREE.MeshPhysicalMaterial({
                        color: 0xFF0000,
                        metalness: 0.02,
                        roughness: 0.55,
                        clearcoat: 0.08,
                        clearcoatRoughness: 0.6,
                        sheen: 0.15,
                        sheenRoughness: 0.8,
                        envMapIntensity: 0.9,
                        transparent: false,
                        opacity: 1.0
                    });
                    child.material = shoeMaterial;
                }
            });
            this.objectsParent.add(this.productModel);
            this.productModel.visible = true;
            if (this.cloudModel) this.cloudModel.visible = false;
            gsap.killTweensOf(this.productModel.position);
            gsap.killTweensOf(this.productModel.rotation);
            gsap.killTweensOf(this.productModel.scale);
            this.productModel.position.set(0, 0.03, 0);
            this.productModel.rotation.set(0, 0, 0);
            const currentScale = this.sizeScales[this.selectedSizeIndex] || 1.0;
            this.productModel.scale.set(currentScale, currentScale, currentScale);
            if (onLoad) onLoad();
        }, 
        (xhr) => {},
        (error) => {
            const cubeGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const cubeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0066FF,
                metalness: 0.4,
                roughness: 0.35,
                envMapIntensity: 1.5,
                transparent: false,
                opacity: 1.0
            });
            this.productModel = new THREE.Mesh(cubeGeometry, cubeMaterial);
            const initialScale = this.sizeScales[this.selectedSizeIndex] || 1.0;
            this.productModel.scale.set(initialScale, initialScale, initialScale);
            this.productModel.position.set(0, 0.03, 0);
            this.productModel.rotation.set(0, 0, 0);
            this.objectsParent.add(this.productModel);
            this.productModel.visible = true;
            if (this.cloudModel) this.cloudModel.visible = false;
            this.currentObjectType = 'shoe';
            if (onLoad) onLoad();
        });
    }
    loadCloud(onLoad, createDotPlanesCallback) {
        this.loader.load('/static/cloud.glb', (gltf) => {
            this.cloudModel = gltf.scene;
            this.cloudModel.scale.set(0.205, 0.205, 0.205);
            this.cloudModel.position.set(0, 0.03, 0);
            this.cloudModel.rotation.set(0, 0, 0);
            this.objectsParent.add(this.cloudModel);
            const centerSphereGeometry = new THREE.SphereGeometry(0.02, 16, 16);
            const centerSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });
            const centerSphere = new THREE.Mesh(centerSphereGeometry, centerSphereMaterial);
            centerSphere.scale.set(1, 1, 1);
            centerSphere.position.set(0, 0, 0);
            this.cloudModel.add(centerSphere);
            this.cloudModel.visible = false;
            if (createDotPlanesCallback) {
                createDotPlanesCallback(this.cloudModel);
            }
            gsap.killTweensOf(this.cloudModel.position);
            gsap.killTweensOf(this.cloudModel.rotation);
            gsap.killTweensOf(this.cloudModel.scale);
            this.cloudModel.position.set(0, 0.03, 0);
            this.cloudModel.rotation.set(0, 0, 0);
            this.cloudModel.scale.set(0.205, 0.205, 0.205);
            if (onLoad) onLoad();
        }, 
        (xhr) => {},
        (error) => {
            const sphereGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const sphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF6600,
                metalness: 0.0,
                roughness: 0.8,
                envMapIntensity: 1.0,
                transparent: false,
                opacity: 1.0,
                flatShading: true
            });
            this.cloudModel = new THREE.Mesh(sphereGeometry, sphereMaterial);
            this.cloudModel.scale.set(0.432, 0.432, 0.432);
            this.cloudModel.position.set(0, 0.05, 0);
            this.objectsParent.add(this.cloudModel);
            this.cloudModel.visible = false;
            if (onLoad) onLoad();
        });
    }
    toggleShoeCloudVisibility(context) {
        const { header, headerTags, groundPlane, colorPicker, cachedDotPlanes } = context;
        if (this.productModel && this.cloudModel) {
            if (this.productModel.visible) {
                this.currentObjectType = 'cloud';
                if (colorPicker) {
                    colorPicker.closeColorCircle();
                }
                this.cloudModel.rotation.x = this.cloudRotation.x;
                this.cloudModel.rotation.y = this.cloudRotation.y;
                gsap.to(header.scale, {
                    x: 0.0, y: 0.0, z: 0.0,
                    duration: 0.3,
                    ease: "power2.inOut",
                    onComplete: () => {
                        gsap.to(headerTags.scale, {
                            x: 1.0, y: 1.0, z: 1.0,
                            duration: 0.3,
                            ease: "power2.out"
                        });
                    }
                });
                gsap.to(groundPlane.scale, {
                    x: 0.0, y: 0.0, z: 0.0,
                    duration: 0.3,
                    ease: "power2.inOut",
                    delay: 0.1
                });
                gsap.to(this.productModel.scale, {
                    x: 0, y: 0, z: 0,
                    duration: 0.3,
                    ease: "power2.inOut",
                    onComplete: () => {
                        this.productModel.visible = false;
                    }
                });
                this.cloudModel.scale.set(0, 0, 0);
                this.cloudModel.visible = true;
                if (cachedDotPlanes) {
                    for (let i = 0; i < cachedDotPlanes.length; i++) {
                        const child = cachedDotPlanes[i];
                        if (child && child.isMesh && child.material && 
                            child.material.color && child.material.color.getHex() === 0x00ff00) {
                            child.visible = true;
                            child.scale.set(1, 1, 1);
                            child.frustumCulled = false;
                        }
                    }
                }
                gsap.to(this.cloudModel.scale, {
                    x: 0.205, y: 0.205, z: 0.205,
                    duration: 0.3,
                    ease: "power2.out",
                    delay: 0.3
                });
            } else {
                this.currentObjectType = 'shoe';
                this.productModel.rotation.y = this.shoeRotation.y;
                gsap.to(headerTags.scale, {
                    x: 0.0, y: 0.0, z: 0.0,
                    duration: 0.3,
                    ease: "power2.inOut",
                    onComplete: () => {
                        gsap.to(header.scale, {
                            x: 1.0, y: 1.0, z: 1.0,
                            duration: 0.3,
                            ease: "power2.out"
                        });
                    }
                });
                gsap.to(groundPlane.scale, {
                    x: 1.0, y: 1.0, z: 1.0,
                    duration: 0.3,
                    ease: "power2.inOut",
                    delay: 0.3
                });
                gsap.to(this.cloudModel.scale, {
                    x: 0, y: 0, z: 0,
                    duration: 0.3,
                    ease: "power2.inOut",
                    onComplete: () => {
                        this.cloudModel.visible = false;
                    }
                });
                this.productModel.scale.set(0, 0, 0);
                this.productModel.visible = true;
                if (colorPicker && colorPicker.getColorButton().material.color) {
                    colorPicker.updateShoeColor(colorPicker.getColorButton().material.color);
                }
                const targetScale = this.sizeScales[this.selectedSizeIndex] || 1.0;
                gsap.to(this.productModel.scale, {
                    x: targetScale,
                    y: targetScale,
                    z: targetScale,
                    duration: 0.3,
                    ease: "power2.out",
                    delay: 0.3
                });
            }
        }
    }
    getProductModel() {
        return this.productModel;
    }
    getCloudModel() {
        return this.cloudModel;
    }
    getShoeColorLayer() {
        return this.shoeColorLayer;
    }
    getCurrentObjectType() {
        return this.currentObjectType;
    }
    getShoeRotation() {
        return this.shoeRotation;
    }
    getCloudRotation() {
        return this.cloudRotation;
    }
    getRotationSpeed() {
        return this.rotationSpeed;
    }
}

====== CONTENT OF: sneaker\src\style.css ======
.webgl
{
    position: fixed;
    top: 0;
    left: 0
}
html, 
body 
{
    overflow: hidden;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}
/* Instruction overlay for full-screen click to start XR (matches ONLYREFERENCE) */
body::before {
    content: "Start WebXR";
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #ffff00;
    color: #000;
    padding: 20px 40px;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: 18px;
    font-weight: bold;
    z-index: 1000;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
/* Hide instruction when XR session is active */
body.xr-presenting::before {
    opacity: 0;
}
/* Force-hide any default WebXR buttons that might be injected */
.xr-button,
.webxr-button,
button.webxr-button {
    display: none !important;
}

====== CONTENT OF: sneaker\src\UIColorPicker.js ======
import * as THREE from 'three';
import gsap from 'gsap';
export class UIColorPicker {
    constructor(header, textureLoader, configureTexture) {
        this.header = header;
        this.textureLoader = textureLoader;
        this.configureTexture = configureTexture;
        this.colorButton = null;
        this.colorCircleOrigin = null;
        this.colorCirclePlane = null;
        this.colorCircleCenter = null;
        this.colorCircleDot = null;
        this.closeButtonPlane = null;
        this.colorCircleOpen = false;
        this.shoeColorLayer = null;
        this.initColorPicker();
    }
    initColorPicker() {
        const sphereGeometry = new THREE.SphereGeometry(0.025, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        this.colorButton = new THREE.Mesh(sphereGeometry, sphereMaterial);
        const closeButtonGeometry = new THREE.PlaneGeometry(0.04, 0.04);
        const closeButtonTexture = this.configureTexture(
            this.textureLoader.load('/static/ui_close.png')
        );
        const closeButtonMaterial = new THREE.MeshBasicMaterial({
            map: closeButtonTexture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false,
            toneMapped: false
        });
        this.closeButtonPlane = new THREE.Mesh(closeButtonGeometry, closeButtonMaterial);
        this.closeButtonPlane.position.set(0, 0, 0);
        this.closeButtonPlane.scale.set(0, 0, 0);
        this.colorButton.add(this.closeButtonPlane);
        this.colorCircleOrigin = new THREE.Object3D();
        const colorPickerPosition = new THREE.Vector3(-0.15, -0.06, 0);
        this.colorButton.position.copy(colorPickerPosition);
        this.colorCircleOrigin.position.copy(colorPickerPosition);
        this.colorCircleOrigin.scale.set(0, 0, 0);
        this.colorButton.userData.isPressed = false;
        const childPlaneSize = 0.2;
        const childPlaneGeometry = new THREE.PlaneGeometry(childPlaneSize, childPlaneSize);
        const colorCircleTexture = this.configureTexture(
            this.textureLoader.load('/static/ui_colorcircle.png')
        );
        const childPlaneMaterial = new THREE.MeshBasicMaterial({ 
            map: colorCircleTexture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            toneMapped: false
        });
        this.colorCirclePlane = new THREE.Mesh(childPlaneGeometry, childPlaneMaterial);
        this.colorCirclePlane.position.set(0, 0, 0.05);
        this.colorCircleCenter = new THREE.Object3D();
        this.colorCircleCenter.position.set(0, 0, 0);
        this.colorCirclePlane.add(this.colorCircleCenter);
        this.colorCircleOrigin.add(this.colorCirclePlane);
        this.createColorCircleDot();
        this.header.add(this.colorButton);
        this.header.add(this.colorCircleOrigin);
    }
    createColorCircleDot() {
        this.colorCircleDot = new THREE.Mesh(
            new THREE.SphereGeometry(0.017, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xFF0000 })
        );
        const dotPlaneGeometry = new THREE.CircleGeometry(0.0225, 32);
        const dotCircleTexture = this.configureTexture(
            this.textureLoader.load('/static/ui_dotcircle.png')
        );
        const dotPlaneMaterial = new THREE.MeshBasicMaterial({ 
            map: dotCircleTexture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            depthTest: false,
            depthWrite: false,
            toneMapped: false
        });
        const dotPlane = new THREE.Mesh(dotPlaneGeometry, dotPlaneMaterial);
        dotPlane.position.set(0, 0, 0.002);
        this.colorCircleDot.add(dotPlane);
        this.colorCircleDot.renderOrder = 1;
        dotPlane.renderOrder = 1;
        this.colorCircleDot.position.set(0.081, 0, 0);
        this.colorCircleDot.userData.radius = 0.081;
        this.colorCircleDot.userData.isDragging = false;
        this.colorCircleDot.userData.activeHand = null;
        this.colorCirclePlane.add(this.colorCircleDot);
    }
    setShoeColorLayer(layer) {
        this.shoeColorLayer = layer;
    }
    updateShoeColor(color) {
        if (this.shoeColorLayer && this.shoeColorLayer.material) {
            this.shoeColorLayer.material.color.copy(color);
            this.shoeColorLayer.material.needsUpdate = true;
        }
    }
    toggleColorCircle() {
        this.colorCircleOpen = !this.colorCircleOpen;
        gsap.to(this.colorButton.scale, {
            x: 0.7, y: 0.7, z: 0.7,
            duration: 0.1,
            ease: "power2.out",
            onComplete: () => {
                gsap.to(this.colorButton.scale, {
                    x: 1, y: 1, z: 1,
                    duration: 0.2,
                    ease: "power2.out"
                });
            }
        });
        gsap.to(this.colorCircleOrigin.scale, {
            x: this.colorCircleOpen ? 1 : 0,
            y: this.colorCircleOpen ? 1 : 0,
            z: this.colorCircleOpen ? 1 : 0,
            duration: 0.3,
            ease: "power2.inOut"
        });
        gsap.to(this.closeButtonPlane.scale, {
            x: this.colorCircleOpen ? 1 : 0,
            y: this.colorCircleOpen ? 1 : 0,
            z: this.colorCircleOpen ? 1 : 0,
            duration: 0.3,
            ease: "power2.inOut"
        });
    }
    handleColorButtonInteraction(lIndexObj, rIndexObj, currentTime, 
                                  lastButtonTouchTime, buttonTouchCooldown) {
        const colorButtonWorldPosition = new THREE.Vector3();
        this.colorButton.getWorldPosition(colorButtonWorldPosition);
        const leftIndexToColorButton = lIndexObj ? 
            lIndexObj.position.distanceTo(colorButtonWorldPosition) : Infinity;
        const rightIndexToColorButton = rIndexObj ? 
            rIndexObj.position.distanceTo(colorButtonWorldPosition) : Infinity;
        if ((leftIndexToColorButton < 0.06 || rightIndexToColorButton < 0.06) && 
            (currentTime - lastButtonTouchTime) > buttonTouchCooldown) {
            this.toggleColorCircle();
            return true;
        }
        return false;
    }
    handleColorCircleDotInteraction(lPinchOn, rPinchOn, lPinchSphere, rPinchSphere) {
        if (!this.colorCircleOpen) return;
        const dotWorldPosition = new THREE.Vector3();
        this.colorCircleDot.getWorldPosition(dotWorldPosition);
        const centerWorldPosition = new THREE.Vector3();
        this.colorCircleCenter.getWorldPosition(centerWorldPosition);
        const leftPinchingNearDot = lPinchOn && 
            lPinchSphere.position.distanceTo(dotWorldPosition) < 0.06;
        const rightPinchingNearDot = rPinchOn && 
            rPinchSphere.position.distanceTo(dotWorldPosition) < 0.06;
        if (!this.colorCircleDot.userData.isDragging) {
            if (leftPinchingNearDot) {
                this.colorCircleDot.userData.isDragging = true;
                this.colorCircleDot.userData.activeHand = 'left';
            } else if (rightPinchingNearDot) {
                this.colorCircleDot.userData.isDragging = true;
                this.colorCircleDot.userData.activeHand = 'right';
            }
        }
        if (this.colorCircleDot.userData.isDragging) {
            const pinchPosition = this.colorCircleDot.userData.activeHand === 'left' ? 
                lPinchSphere.position : rPinchSphere.position;
            const isStillPinching = this.colorCircleDot.userData.activeHand === 'left' ? 
                lPinchOn : rPinchOn;
            const localPinchPosition = new THREE.Vector3();
            localPinchPosition.copy(pinchPosition);
            this.colorCircleCenter.worldToLocal(localPinchPosition);
            const angle = Math.atan2(localPinchPosition.y, localPinchPosition.x);
            const radius = this.colorCircleDot.userData.radius;
            this.colorCircleDot.position.x = Math.cos(angle) * radius;
            this.colorCircleDot.position.y = Math.sin(angle) * radius;
            this.colorCircleDot.position.z = 0;
            let hue = ((Math.atan2(this.colorCircleDot.position.y, 
                                   this.colorCircleDot.position.x) * 180 / Math.PI) + 360) % 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 1, 0.5);
            this.colorCircleDot.material.color = color;
            this.colorButton.material.color = color;
            this.updateShoeColor(color);
            if (!isStillPinching) {
                this.colorCircleDot.userData.isDragging = false;
                this.colorCircleDot.userData.activeHand = null;
            }
        }
    }
    closeColorCircle() {
        if (this.colorCircleOpen) {
            this.colorCircleOpen = false;
            gsap.to([this.colorCircleOrigin.scale, this.closeButtonPlane.scale], {
                x: 0, y: 0, z: 0,
                duration: 0.3,
                ease: "power2.inOut"
            });
        }
    }
    getColorButton() {
        return this.colorButton;
    }
    getColorCircleDot() {
        return this.colorCircleDot;
    }
    getColorCircleOrigin() {
        return this.colorCircleOrigin;
    }
    getCloseButtonPlane() {
        return this.closeButtonPlane;
    }
    isColorCircleOpen() {
        return this.colorCircleOpen;
    }
    setColorCircleOpen(value) {
        this.colorCircleOpen = value;
    }
}

====== CONTENT OF: sneaker\src\UIHeader.js ======
import * as THREE from 'three';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
import gsap from 'gsap';
export class UIHeader {
    constructor(baseComposition, textureLoader, configureTexture) {
        this.baseComposition = baseComposition;
        this.textureLoader = textureLoader;
        this.configureTexture = configureTexture;
        this.selectedSizeIndex = 2; 
        this.sizeTexts = [];
        this.textConfigs = [];
        this.selector = null;
        this.sizeScales = [0.92, 0.97, 1.02, 1.06, 1.12];
        this.selectorPositions = [
            { x: -0.05, y: -0.06, z: 0.021 },  
            { x: -0.0, y: -0.06, z: 0.021 },   
            { x: 0.056, y: -0.06, z: 0.021 },  
            { x: 0.110, y: -0.06, z: 0.021 },  
            { x: 0.155, y: -0.06, z: 0.021 }   
        ];
        this.header = null;
        this.initHeader();
    }
    initHeader() {
        const headerWidth = 0.406 * 0.9;
        const headerHeight = headerWidth * (201 / 406);
        const headerGeometry = new THREE.PlaneGeometry(headerWidth, headerHeight);
        const headerTexture = this.configureTexture(
            this.textureLoader.load('/static/ui_header.png',
                (texture) => { headerMaterial.needsUpdate = true; },
                (xhr) => {},
                (error) => {}
            )
        );
        const headerMaterial = new THREE.MeshBasicMaterial({ 
            map: headerTexture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            toneMapped: false
        });
        this.header = new THREE.Mesh(headerGeometry, headerMaterial);
        this.header.position.set(0, 0.34, 0);
        this.baseComposition.add(this.header);
        this.loadFont();
    }
    loadFont() {
        const fontLoader = new FontLoader();
        fontLoader.load('/static/fonts/roboto_black.typeface.json', (font) => {
            this.createSizeTexts(font);
            this.createSelector();
            setTimeout(() => {
                this.updateSizeSelection(this.selectedSizeIndex, null);
            }, 100);
        });
    }
    createSizeTexts(font) {
        this.textConfigs = [
            { text: '8', position: [-0.06, -0.07, 0.001], index: 0 },
            { text: '9', position: [-0.01, -0.07, 0.001], index: 1 },
            { text: '9.5', position: [0.032, -0.07, 0.001], index: 2 },
            { text: '10', position: [0.09, -0.07, 0.001], index: 3 },
            { text: '11', position: [0.137, -0.07, 0.001], index: 4 }
        ];
        this.textConfigs.forEach(config => {
            const textGeometry = new TextGeometry(config.text, {
                font: font,
                size: 0.02,
                depth: 0.001,
                curveSegments: 12,
                bevelEnabled: false
            });
            const textMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                toneMapped: false
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(...config.position);
            textMesh.userData.isSizeButton = true;
            textMesh.userData.sizeIndex = config.index;
            textMesh.userData.isPressed = false;
            this.sizeTexts[config.index] = textMesh;
            this.header.add(textMesh);
        });
    }
    createSelector() {
        const selectorGeometry = new THREE.PlaneGeometry(0.06, 0.06);
        const selectorTexture = this.configureTexture(
            this.textureLoader.load('/static/ui_selector.png',
                (texture) => { selectorMaterial.needsUpdate = true; },
                (xhr) => {},
                (error) => {}
            )
        );
        const selectorMaterial = new THREE.MeshBasicMaterial({ 
            map: selectorTexture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            toneMapped: false
        });
        this.selector = new THREE.Mesh(selectorGeometry, selectorMaterial);
        const initialPosition = this.selectorPositions[this.selectedSizeIndex];
        this.selector.position.set(initialPosition.x, initialPosition.y, initialPosition.z);
        this.header.add(this.selector);
    }
    updateSizeSelection(newIndex, productModel) {
        try {
            if (!this.sizeTexts || !Array.isArray(this.sizeTexts)) {
                return;
            }
            this.sizeTexts.forEach((textMesh, index) => {
                if (textMesh && textMesh.material) {
                    try {
                        textMesh.material.color.setHex(0xffffff);
                        textMesh.material.needsUpdate = true;
                        gsap.to(textMesh.scale, {
                            x: 1.0, y: 1.0, z: 1.0,
                            duration: 0.2,
                            ease: "power2.out"
                        });
                    } catch (error) {}
                }
            });
            if (this.sizeTexts[newIndex] && this.sizeTexts[newIndex].material) {
                const selectedText = this.sizeTexts[newIndex];
                try {
                    selectedText.material.color.setHex(0x00FF01);
                    selectedText.material.needsUpdate = true;
                    gsap.to(selectedText.scale, {
                        x: 1.2, y: 1.2, z: 1.2,
                        duration: 0.2,
                        ease: "power2.out"
                    });
                    if (this.selector && this.selectorPositions[newIndex]) {
                        const targetPosition = this.selectorPositions[newIndex];
                        gsap.to(this.selector.position, {
                            x: targetPosition.x,
                            y: targetPosition.y,
                            z: targetPosition.z,
                            duration: 0.3,
                            ease: "power2.out"
                        });
                    }
                } catch (error) {}
            }
            this.selectedSizeIndex = newIndex;
            if (productModel && this.sizeScales[newIndex] !== undefined) {
                const targetScale = this.sizeScales[newIndex];
                gsap.to(productModel.scale, {
                    x: targetScale,
                    y: targetScale,
                    z: targetScale,
                    duration: 0.4,
                    ease: "power2.out"
                });
            }
        } catch (error) {}
    }
    animateSizeButtonPress(buttonIndex, productModel) {
        try {
            const button = this.sizeTexts[buttonIndex];
            if (!button || !button.userData || button.userData.isPressed) return;
            button.userData.isPressed = true;
            gsap.to(button.scale, {
                x: 0.6, y: 0.6, z: 0.6,
                duration: 0.1,
                ease: "power2.out",
                onComplete: () => {
                    try {
                        this.updateSizeSelection(buttonIndex, productModel);
                        setTimeout(() => {
                            if (button && button.userData) {
                                button.userData.isPressed = false;
                            }
                        }, 100);
                    } catch (error) {}
                }
            });
        } catch (error) {}
    }
    handleSizeButtonInteraction(lIndexObj, rIndexObj, productModel, 
                                 currentTime, lastButtonTouchTime, buttonTouchCooldown, 
                                 buttonTouchActive, colorCircleOpen) {
        if (!this.sizeTexts || this.sizeTexts.length === 0) {
            return { shouldUpdateCooldown: false };
        }
        const touchThreshold = 0.03; 
        let closestButton = null;
        let closestDistance = Infinity;
        this.sizeTexts.forEach((sizeButton, index) => {
            if (!sizeButton || !sizeButton.userData) return;
            try {
                const sizeButtonWorldPosition = new THREE.Vector3();
                sizeButton.getWorldPosition(sizeButtonWorldPosition);
                const leftIndexDistance = lIndexObj ? 
                    lIndexObj.position.distanceTo(sizeButtonWorldPosition) : Infinity;
                const rightIndexDistance = rIndexObj ? 
                    rIndexObj.position.distanceTo(sizeButtonWorldPosition) : Infinity;
                const minDistance = Math.min(leftIndexDistance, rightIndexDistance);
                if (minDistance < touchThreshold && minDistance < closestDistance) {
                    closestDistance = minDistance;
                    closestButton = { button: sizeButton, index: index };
                }
                if (minDistance >= touchThreshold && sizeButton.userData.isPressed) {
                    sizeButton.userData.isPressed = false;
                }
            } catch (error) {}
        });
        if (closestButton && !closestButton.button.userData.isPressed && 
            !buttonTouchActive && !colorCircleOpen &&
            (currentTime - lastButtonTouchTime) > buttonTouchCooldown) {
            this.animateSizeButtonPress(closestButton.index, productModel);
            return { shouldUpdateCooldown: true };
        }
        return { shouldUpdateCooldown: false };
    }
    getHeader() {
        return this.header;
    }
    getSizeScales() {
        return this.sizeScales;
    }
    getSelectedSizeIndex() {
        return this.selectedSizeIndex;
    }
}

====== CONTENT OF: sneaker\src\UITagsCloud.js ======
import * as THREE from 'three';
import gsap from 'gsap';
export class UITagsCloud {
    constructor(baseComposition, textureLoader, configureTexture, camera) {
        this.baseComposition = baseComposition;
        this.textureLoader = textureLoader;
        this.configureTexture = configureTexture;
        this.camera = camera;
        this.tagStates = new Array(12).fill(false);
        this.tagStates[0] = true;   
        this.tagStates[2] = true;   
        this.tagStates[4] = true;   
        this.tagStates[6] = true;   
        this.tagStates[8] = true;   
        this.tagStates[10] = true;  
        this.tagStates[11] = true;  
        this.cachedDotPlanes = [];
        this.cachedConnectionBoxes = [];
        this.planeScalingEnabled = true;
        this.planeBaseScale = 1.0;
        this.planeMinScale = 0.7;
        this.planeMaxScale = 1.7;
        this.planeScaleRange = 0.1;
        this.headerTags = null;
        this.initHeaderTags();
    }
    initHeaderTags() {
        const headerTagsWidth = 0.270 * 0.9;
        const headerTagsHeight = headerTagsWidth * (92 / 270);
        const headerTagsGeometry = new THREE.PlaneGeometry(headerTagsWidth, headerTagsHeight);
        const headerTagsTexture = this.configureTexture(
            this.textureLoader.load('/static/ui_header-tags.png',
                (texture) => { headerTagsMaterial.needsUpdate = true; },
                (xhr) => {},
                (error) => {}
            )
        );
        const headerTagsMaterial = new THREE.MeshBasicMaterial({ 
            map: headerTagsTexture,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            toneMapped: false
        });
        this.headerTags = new THREE.Mesh(headerTagsGeometry, headerTagsMaterial);
        this.headerTags.position.set(0, 0.34, 0);
        this.headerTags.scale.set(0, 0, 0);
        this.baseComposition.add(this.headerTags);
    }
    createDotPlanes(cloudModel) {
        if (cloudModel.userData.dotPlanesCreated) return;
        this.cachedDotPlanes.length = 0;
        this.cachedConnectionBoxes.length = 0;
        const connectionMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.4
        });
        const planeGeometry = new THREE.PlaneGeometry(0.8025, 0.235);
        let planesCreated = 0;
        for (let i = 0; i < 12; i++) {
            const dotName = `dot${i}`;
            const dotPart = cloudModel.getObjectByName(dotName);
            if (dotPart) {
                const texturePathOFF = `/static/ui_tag${i}-OFF.png`;
                const texturePathON = `/static/ui_tag${i}-ON.png`;
                const textureOFF = this.configureTexture(this.textureLoader.load(texturePathOFF));
                const textureON = this.configureTexture(this.textureLoader.load(texturePathON));
                const initialTexture = this.tagStates[i] ? textureON : textureOFF;
                const planeMaterial = new THREE.MeshBasicMaterial({ 
                    map: initialTexture,
                    transparent: true,
                    opacity: 1.0,
                    side: THREE.DoubleSide,
                    alphaTest: 0.1,
                    depthTest: false,
                    depthWrite: false,
                    toneMapped: false
                });
                planeMaterial.userData = {
                    textureOFF: textureOFF,
                    textureON: textureON
                };
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.position.set(0, 0, 0.01);
                plane.visible = true;
                plane.frustumCulled = false;
                plane.userData.isDotPlane = true;
                plane.userData.dotIndex = i;
                plane.userData.textureOFF = textureOFF;
                plane.userData.textureON = textureON;
                plane.userData.material = planeMaterial;
                dotPart.add(plane);
                const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
                const connectionBox = new THREE.Mesh(boxGeometry, connectionMaterial);
                connectionBox.scale.set(0.015, 0.015, 1);
                connectionBox.userData.planeRef = plane;
                connectionBox.userData.lineIndex = i;
                cloudModel.add(connectionBox);
                plane.userData.connectionBox = connectionBox;
                this.cachedDotPlanes[i] = plane;
                this.cachedConnectionBoxes[i] = connectionBox;
                planesCreated++;
            }
        }
        if (planesCreated === 0) {
            const textureOFF = this.configureTexture(
                this.textureLoader.load('/static/ui_tag0-OFF.png')
            );
            const textureON = this.configureTexture(
                this.textureLoader.load('/static/ui_tag0-ON.png')
            );
            const testMaterial = new THREE.MeshBasicMaterial({ 
                map: textureOFF,
                transparent: true,
                opacity: 1.0,
                side: THREE.DoubleSide,
                alphaTest: 0.1,
                depthTest: false,
                depthWrite: false,
                toneMapped: false
            });
            const testPlane = new THREE.Mesh(planeGeometry, testMaterial);
            testPlane.position.set(0, 0, 0.1);
            testPlane.visible = true;
            testPlane.frustumCulled = false;
            testPlane.userData.isDotPlane = true;
            testPlane.userData.textureOFF = textureOFF;
            testPlane.userData.textureON = textureON;
            testPlane.userData.material = testMaterial;
            cloudModel.add(testPlane);
        }
        cloudModel.userData.dotPlanesCreated = true;
    }
    updateDotPlanesToFaceCamera(cloudModel) {
        if (!cloudModel || !cloudModel.visible) return;
        for (let i = 0; i < this.cachedDotPlanes.length; i++) {
            const child = this.cachedDotPlanes[i];
            if (!child || !child.userData.isDotPlane) continue;
            const planeWorldPosition = new THREE.Vector3();
            child.getWorldPosition(planeWorldPosition);
            child.lookAt(this.camera.position);
            if (this.planeScalingEnabled) {
                const cloudWorldPosition = new THREE.Vector3();
                cloudModel.getWorldPosition(cloudWorldPosition);
                const relativePosition = new THREE.Vector3();
                relativePosition.subVectors(planeWorldPosition, cloudWorldPosition);
                const zDepth = relativePosition.z;
                const zRange = 0.3;
                const normalizedZ = Math.max(0, Math.min(1, (zDepth + zRange/2) / zRange));
                const scaleFactor = this.planeMinScale + 
                    (normalizedZ * (this.planeMaxScale - this.planeMinScale));
                child.scale.set(scaleFactor, scaleFactor, scaleFactor);
                if (child.userData.connectionBox) {
                    const box = child.userData.connectionBox;
                    const dotPart = child.parent;
                    if (!dotPart) return;
                    const startPos = new THREE.Vector3(0, 0, 0);
                    const endPos = dotPart.position.clone();
                    const direction = endPos.clone().sub(startPos);
                    const distance = direction.length();
                    if (distance > 0) {
                        box.position.copy(startPos).add(direction.multiplyScalar(0.5));
                        box.scale.set(0.015, distance, 0.015);
                        const quaternion = new THREE.Quaternion();
                        const up = new THREE.Vector3(0, 1, 0);
                        quaternion.setFromUnitVectors(up, direction.normalize());
                        box.quaternion.copy(quaternion);
                    }
                }
            }
        }
    }
    handleTagInteraction(lIndexObj, rIndexObj, cloudModel, currentTime, 
                        lastButtonTouchTime, buttonTouchCooldown, buttonTouchActive) {
        if (!cloudModel || !cloudModel.visible) return { shouldUpdateCooldown: false };
        for (let i = 0; i < this.cachedDotPlanes.length; i++) {
            const child = this.cachedDotPlanes[i];
            if (!child || !child.userData.isDotPlane) continue;
            const tagIndex = child.userData.dotIndex;
            if (tagIndex === undefined) continue;
            const tagWorldPosition = new THREE.Vector3();
            child.getWorldPosition(tagWorldPosition);
            const leftIndexDistance = lIndexObj ? 
                lIndexObj.position.distanceTo(tagWorldPosition) : Infinity;
            const rightIndexDistance = rIndexObj ? 
                rIndexObj.position.distanceTo(tagWorldPosition) : Infinity;
            const touchThreshold = 0.05;
            const isTouching = leftIndexDistance < touchThreshold || 
                              rightIndexDistance < touchThreshold;
            if (isTouching && !child.userData.isPressed && !buttonTouchActive && 
                (currentTime - lastButtonTouchTime) > buttonTouchCooldown) {
                child.userData.isPressed = true;
                this.tagStates[tagIndex] = !this.tagStates[tagIndex];
                const material = child.material;
                if (this.tagStates[tagIndex]) {
                    material.map = material.userData.textureON;
                } else {
                    material.map = material.userData.textureOFF;
                }
                material.needsUpdate = true;
                gsap.killTweensOf(child.scale);
                const wasScalingEnabled = this.planeScalingEnabled;
                this.planeScalingEnabled = false;
                const originalScale = child.scale.x;
                gsap.to(child.scale, {
                    x: originalScale * 0.7,
                    y: originalScale * 0.7,
                    z: originalScale * 0.7,
                    duration: 0.12,
                    ease: "power2.out",
                    onComplete: () => {
                        gsap.to(child.scale, {
                            x: originalScale,
                            y: originalScale,
                            z: originalScale,
                            duration: 0.3,
                            ease: "power2.out",
                            onComplete: () => {
                                this.planeScalingEnabled = wasScalingEnabled;
                            }
                        });
                    }
                });
                return { shouldUpdateCooldown: true };
            } else if (!isTouching && child.userData.isPressed) {
                child.userData.isPressed = false;
            }
        }
        return { shouldUpdateCooldown: false };
    }
    showHeaderTags() {
        gsap.to(this.headerTags.scale, {
            x: 1.0, y: 1.0, z: 1.0,
            duration: 0.3,
            ease: "power2.out"
        });
    }
    hideHeaderTags() {
        gsap.to(this.headerTags.scale, {
            x: 0.0, y: 0.0, z: 0.0,
            duration: 0.3,
            ease: "power2.inOut"
        });
    }
    getHeaderTags() {
        return this.headerTags;
    }
}

====== CONTENT OF: sneaker\src\XRSetup.js ======
import * as THREE from 'three';
import { XRButton } from 'three/addons/webxr/XRButton.js';
export class XRSetup {
    constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.renderer = null;
        this.pmrem = null;
        this.xrButton = null;
        this.defaultBackground = new THREE.Color(0x505050);
        this.compositionPositioned = false;
        this.xrSessionStartTime = null;
        this.initRenderer();
        this.initXRButton();
        this.setupEventListeners();
    }
    initRenderer() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.xr.enabled = true;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.physicallyCorrectLights = true;
        this.renderer.shadowMap.enabled = false;
        document.body.appendChild(this.renderer.domElement);
        this.pmrem = new THREE.PMREMGenerator(this.renderer);
        this.pmrem.compileEquirectangularShader();
    }
    initXRButton() {
        this.xrButton = XRButton.createButton(this.renderer, { 
            'optionalFeatures': ['hand-tracking'] 
        });
        this.xrButton.style.display = 'none';
        this.xrButton.style.opacity = '0';
        this.xrButton.style.pointerEvents = 'none';
        this.xrButton.setAttribute('aria-hidden', 'true');
        document.body.appendChild(this.xrButton);
        document.body.style.cursor = 'pointer';
        const onBodyClickToEnterXR = () => {
            this.xrButton.click();
        };
        document.body.addEventListener('click', onBodyClickToEnterXR, { passive: true });
        this.hideDefaultXRButtons();
    }
    hideDefaultXRButtons() {
        const hideDefaultXRButtonsInTree = (root) => {
            if (!root) return;
            const candidates = root.querySelectorAll ? 
                root.querySelectorAll('button, a, div, canvas, span') : [];
            const shouldHide = (el) => {
                if (!(el instanceof HTMLElement)) return false;
                const cls = (el.className || '').toString().toLowerCase();
                const id = (el.id || '').toString().toLowerCase();
                const txt = (el.textContent || '').toLowerCase();
                if (cls.includes('xr') || cls.includes('webxr') || cls.includes('vr')) return true;
                if (id.includes('xr') || id.includes('webxr') || id.includes('vr')) return true;
                if (/enter\s*(xr|ar|vr)/i.test(txt) || /start\s*(xr|ar|vr)/i.test(txt)) return true;
                return false;
            };
            candidates.forEach((el) => {
                if (shouldHide(el) && el !== this.xrButton) {
                    el.style.display = 'none';
                    el.style.opacity = '0';
                    el.style.pointerEvents = 'none';
                    el.setAttribute('aria-hidden', 'true');
                }
            });
        };
        hideDefaultXRButtonsInTree(document.body);
        const mo = new MutationObserver((mutations) => {
            for (const m of mutations) {
                if (m.type === 'childList') {
                    m.addedNodes.forEach((n) => {
                        if (n instanceof HTMLElement) {
                            hideDefaultXRButtonsInTree(n);
                        }
                    });
                }
            }
        });
        mo.observe(document.body, { childList: true, subtree: true });
    }
    setupEventListeners() {
        this.renderer.xr.addEventListener('sessionstart', () => this.onSessionStart());
        this.renderer.xr.addEventListener('sessionend', () => this.onSessionEnd());
        this.renderer.xr.addEventListener('sessionstart', () => {
            document.body.classList.add('xr-presenting');
            this.scene.background = null; 
        });
        this.renderer.xr.addEventListener('sessionend', () => {
            document.body.classList.remove('xr-presenting');
            this.scene.background = this.defaultBackground;
        });
    }
    onSessionStart() {
        this.xrSessionStartTime = Date.now();
        this.compositionPositioned = false;
    }
    onSessionEnd() {
        this.xrSessionStartTime = null;
        this.compositionPositioned = false;
    }
    positionCompositionAtHeadHeight(baseComposition, productModel, sizeScales, selectedSizeIndex) {
        if (this.compositionPositioned || !this.xrSessionStartTime) return;
        const elapsedTime = Date.now() - this.xrSessionStartTime;
        if (elapsedTime < 1000) return; 
        const headHeight = this.camera.position.y;
        const headDistance = this.camera.position.z;
        baseComposition.position.set(0, headHeight - 0.2, headDistance - 1.0);
        if (productModel) {
            productModel.position.set(0, 0.03, 0);
            productModel.rotation.set(0, 0, 0);
        }
        this.compositionPositioned = true;
    }
    getRenderer() {
        return this.renderer;
    }
    getPMREM() {
        return this.pmrem;
    }
    setAnimationLoop(callback) {
        this.renderer.setAnimationLoop(callback);
    }
    render() {
        this.renderer.render(this.scene, this.camera);
    }
}

====== CONTENT OF: tictactoe\index.html ======
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Tic-Tac-Toe Demo</title>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body>
    <canvas class ="webgl"> </canvas>
    <script type="module" src="./src/main.js"></script>
</body>
</html>

====== CONTENT OF: tictactoe\vite.config.js ======
import glsl from 'vite-plugin-glsl'
export default {
    root: './',
    publicDir: './public/',
    base: './',
    server:
    {
        host: true, 
        open: !('SANDBOX_URL' in process.env || 'CODESANDBOX_HOST' in process.env) 
    },
    build:
    {
        outDir: './dist', 
        emptyOutDir: true, 
        sourcemap: true 
    },
    plugins:
    [
        glsl()
    ]
}

====== CONTENT OF: tictactoe\src\BoardView.js ======
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import gsap from 'gsap';
const SPHERE_RADIUS = 0.05;
const PICK_THRESHOLD = 0.05;
export class BoardView {
  constructor(
    scene,
    { orangeMaterial, lightBlueMaterial, xModelTemplate, oModelTemplate }
  ) {
    this.scene = scene;
    this.orangeMaterial = orangeMaterial;
    this.lightBlueMaterial = lightBlueMaterial;
    this.xModelTemplate = xModelTemplate;
    this.oModelTemplate = oModelTemplate;
    this.baseComposition = this._createBaseComposition();
    this.baseGrid = null;
    this.spherePositions = new Map(); 
    this.usedSpheres = new Map();     
    this.activePieces = new Set();    
    this.winLine = null;
    this.scene.add(this.baseComposition);
  }
  _createBaseComposition() {
    const tempGeo = new THREE.BoxGeometry(0.11, 0.11, 0.11);
    const tempMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.0,
      depthTest: false,
      depthWrite: false
    });
    const mesh = new THREE.Mesh(tempGeo, tempMat);
    mesh.scale.set(1, 1, 1);
    return mesh;
  }
  async loadGridModel(url = '/static/tictactoe.glb') {
    const loader = new GLTFLoader();
    return new Promise((resolve) => {
      loader.load(
        url,
        (gltf) => {
          this.baseGrid = gltf.scene;
          this.baseGrid.scale.set(0.11, 0.11, 0.11);
          this.baseGrid.position.set(0, -0.21, 0);
          this.baseGrid.rotation.set(0, 0, 0);
          this.baseGrid.traverse((child) => {
            if (child.isMesh && (!child.name || !child.name.startsWith('Sphere_'))) {
              child.visible = false;
            }
          });
          this.baseComposition.add(this.baseGrid);
          this._createSpheresFromDots(this.baseGrid);
          resolve(this.baseGrid);
        },
        undefined,
        (error) => {
          console.error('Error loading tictactoe.glb:', error);
          const cubeGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
          const cubeMaterial = new THREE.MeshLambertMaterial({
            color: 0x808080,
            transparent: false
          });
          this.baseGrid = new THREE.Mesh(cubeGeometry, cubeMaterial);
          this.baseGrid.scale.set(0.15, 0.15, 0.15);
          this.baseGrid.position.set(0, -0.22, 0);
          this.baseGrid.rotation.set(0, 0, 0);
          this.baseComposition.add(this.baseGrid);
          resolve(this.baseGrid);
        }
      );
    });
  }
  _createSpheresFromDots(root) {
    root.traverse((child) => {
      if (child.isMesh && child.name && child.name.startsWith('Dot_')) {
        const sphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.8
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.name = child.name.replace('Dot_', 'Sphere_');
        sphere.position.copy(child.position);
        child.parent.add(sphere);
        const coords = child.name.split('_')[1];
        if (coords && coords.length === 3) {
          const x = parseInt(coords[0], 10);
          const y = parseInt(coords[1], 10);
          const z = parseInt(coords[2], 10);
          this.spherePositions.set(sphere.uuid, { x, y, z });
        }
      }
    });
  }
  findNearestSphere(worldPos) {
    if (!this.baseGrid) return null;
    let nearest = null;
    let minDist = Infinity;
    const tmp = new THREE.Vector3();
    this.baseGrid.traverse((child) => {
      if (
        child.isMesh &&
        child.name &&
        child.name.startsWith('Sphere_') &&
        child.visible
      ) {
        child.getWorldPosition(tmp);
        const d = worldPos.distanceTo(tmp);
        if (d < minDist) {
          minDist = d;
          nearest = child;
        }
      }
    });
    return minDist < PICK_THRESHOLD ? nearest : null;
  }
  getGridCoordsFromSphere(sphereUUID) {
    return this.spherePositions.get(sphereUUID) || null;
  }
  findSphereByGridPos(x, y, z) {
    if (!this.baseGrid) return null;
    let found = null;
    for (const [uuid, pos] of this.spherePositions.entries()) {
      if (pos.x === x && pos.y === y && pos.z === z) {
        this.baseGrid.traverse((child) => {
          if (child.isMesh && child.uuid === uuid) {
            found = child;
          }
        });
        if (found) break;
      }
    }
    return found;
  }
  worldToLocalOnGrid(worldPos) {
    if (!this.baseGrid) return null;
    const local = worldPos.clone();
    this.baseGrid.worldToLocal(local);
    return local;
  }
  markSphereUsed(sphereUUID, player) {
    this.usedSpheres.set(sphereUUID, player);
  }
  isSphereFree(sphereUUID) {
    return !this.usedSpheres.has(sphereUUID);
  }
  spawnO(localPos) {
    let root;
    if (this.oModelTemplate && this.baseGrid) {
      root = this.oModelTemplate.clone();
    } else {
      console.warn('BoardView.spawnO: oModelTemplate missing, using fallback sphere.');
      const geo = new THREE.SphereGeometry(0.045, 24, 24);
      root = new THREE.Mesh(geo, this.orangeMaterial);
    }
    root.position.copy(localPos);
    this.baseGrid.add(root);
    this.activePieces.add(root);
    root.scale.set(0.01, 0.01, 0.01);
    gsap.to(root.scale, {
      x: 0.9,
      y: 0.9,
      z: 0.9,
      duration: 0.3,
      ease: 'back.out'
    });
    return root;
  }
  spawnX(localPos) {
    let root;
    if (this.xModelTemplate && this.baseGrid) {
      root = this.xModelTemplate.clone();
    } else {
      console.warn('BoardView.spawnX: xModelTemplate missing, using fallback cross.');
      root = new THREE.Group();
      const barGeo = new THREE.BoxGeometry(0.08, 0.02, 0.02);
      const bar1 = new THREE.Mesh(barGeo, this.lightBlueMaterial);
      const bar2 = new THREE.Mesh(barGeo, this.lightBlueMaterial);
      bar1.rotation.z = Math.PI / 4;
      bar2.rotation.z = -Math.PI / 4;
      root.add(bar1, bar2);
    }
    root.position.copy(localPos);
    this.baseGrid.add(root);
    this.activePieces.add(root);
    root.scale.set(0.01, 0.01, 0.01);
    gsap.to(root.scale, {
      x: 1.0,
      y: 1.0,
      z: 1.0,
      duration: 0.3,
      ease: 'back.out'
    });
    return root;
  }
  showWinningLine(startGrid, endGrid, material) {
    if (!this.baseGrid) return;
    const startSphere = this.findSphereByGridPos(
      startGrid.x,
      startGrid.y,
      startGrid.z
    );
    const endSphere = this.findSphereByGridPos(
      endGrid.x,
      endGrid.y,
      endGrid.z
    );
    if (!startSphere || !endSphere) return;
    const startWorld = new THREE.Vector3();
    const endWorld = new THREE.Vector3();
    startSphere.getWorldPosition(startWorld);
    endSphere.getWorldPosition(endWorld);
    const startLocal = this.baseGrid.worldToLocal(startWorld.clone());
    const endLocal = this.baseGrid.worldToLocal(endWorld.clone());
    const midPoint = new THREE.Vector3()
      .addVectors(startLocal, endLocal)
      .multiplyScalar(0.5);
    const distance = startLocal.distanceTo(endLocal);
    const geometry = new THREE.CylinderGeometry(0.04, 0.04, distance, 16);
    const lineMaterial =
      material ||
      new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        depthTest: true,
        depthWrite: true
      });
    const cylinder = new THREE.Mesh(geometry, lineMaterial);
    cylinder.position.copy(midPoint);
    const dir = new THREE.Vector3().subVectors(endLocal, startLocal).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    const quat = new THREE.Quaternion().setFromUnitVectors(up, dir);
    cylinder.quaternion.copy(quat);
    this.baseGrid.add(cylinder);
    this.winLine = cylinder;
    gsap.from(cylinder.scale, {
      y: 0,
      duration: 0.3,
      ease: 'power2.out'
    });
  }
  resetVisuals() {
    if (this.winLine) {
      if (this.winLine.parent) this.winLine.parent.remove(this.winLine);
      if (this.winLine.geometry) {
        this.winLine.geometry.dispose();
      }
      if (this.winLine.material && this.winLine.material.isMaterial) {
        this.winLine.material.dispose();
      }
      this.winLine = null;
    }
    this.activePieces.forEach((piece) => {
      gsap.to(piece.scale, {
        x: 0,
        y: 0,
        z: 0,
        duration: 0.2,
        ease: 'power3.in',
        onComplete: () => {
          if (piece.parent) piece.parent.remove(piece);
          piece.traverse?.((n) => {
            if (n.isMesh) {
              n.geometry?.dispose?.();
            }
          });
        }
      });
    });
    this.activePieces.clear();
    if (this.baseGrid) {
      this.baseGrid.traverse((child) => {
        if (child.isMesh && child.name && child.name.startsWith('Sphere_')) {
          child.visible = true;
        }
      });
    }
    this.usedSpheres.clear();
  }
}

====== CONTENT OF: tictactoe\src\EndGameUI.js ======
import * as THREE from 'three';
import gsap from 'gsap';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
export class EndGameUI {
  constructor(
    parent,
    { xModelTemplate, orangeMaterial, lightBlueMaterial }
  ) {
    this.parent = parent;
    this.xModelTemplate = xModelTemplate;
    this.orangeMaterial = orangeMaterial;
    this.lightBlueMaterial = lightBlueMaterial;
    this.endGameOPlane = null;
    this.endGameXPlane = null;
    this.endGameButtonPlane = null;
    this.buttonAnimating = false;
    this.buttonCallback = null;
    this.font = null;
    this.currentText = null;
    this._createPlanes();
    this._attachUIModels();
  }
  _createPlanes() {
    const textureLoader = new THREE.TextureLoader();
    const winsTexture = textureLoader.load('/static/ui_wins.png');
    const buttonTexture = textureLoader.load('/static/ui_button.png');
    winsTexture.encoding = THREE.sRGBEncoding;
    buttonTexture.encoding = THREE.sRGBEncoding;
    this.endGameOPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(0.2592, 0.076464),
      new THREE.MeshBasicMaterial({
        map: winsTexture,
        transparent: true,
        opacity: 1.0,
        side: THREE.DoubleSide
      })
    );
    this.endGameOPlane.position.set(0, 0.12, 0);
    this.endGameOPlane.scale.set(0, 0, 0);
    this.parent.add(this.endGameOPlane);
    this.endGameXPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(0.2592, 0.076464),
      new THREE.MeshBasicMaterial({
        map: winsTexture.clone(),
        transparent: true,
        opacity: 1.0,
        side: THREE.DoubleSide
      })
    );
    this.endGameXPlane.position.set(0, 0.12, 0);
    this.endGameXPlane.scale.set(0, 0, 0);
    this.parent.add(this.endGameXPlane);
    this.endGameButtonPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(0.139968, 0.0401436),
      new THREE.MeshBasicMaterial({
        map: buttonTexture,
        transparent: true,
        opacity: 1.0,
        side: THREE.DoubleSide
      })
    );
    this.endGameButtonPlane.position.set(0, 0.04, 0);
    this.endGameButtonPlane.scale.set(0, 0, 0);
    this.parent.add(this.endGameButtonPlane);
  }
  _attachUIModels() {
    const uiSphereGeometry = new THREE.SphereGeometry(0.025, 32, 32);
    const uiOSphere = new THREE.Mesh(uiSphereGeometry, this.orangeMaterial);
    uiOSphere.position.set(-0.085, 0, 0.0);
    uiOSphere.name = 'uiOrangeSphere';
    this.endGameOPlane.add(uiOSphere);
    if (this.xModelTemplate) {
      const uiX = this.xModelTemplate.clone();
      uiX.name = 'uiXModel';
      uiX.position.set(-0.085, 0, 0.0);
      uiX.scale.set(0.08, 0.08, 0.08);
      uiX.rotation.y = Math.PI / 4;
      this.endGameXPlane.add(uiX);
    }
  }
  getButtonPlane() {
    return this.endGameButtonPlane;
  }
  onButtonPress(cb) {
    this.buttonCallback = cb;
  }
  triggerButtonPress() {
    if (this.buttonAnimating) return;
    if (!this.endGameButtonPlane) return;
    this.buttonAnimating = true;
    gsap.to(this.endGameButtonPlane.scale, {
      x: 0.7,
      y: 0.7,
      z: 0.7,
      duration: 0.2,
      ease: 'power2.out',
      onComplete: () => {
        gsap.to(this.endGameButtonPlane.scale, {
          x: 1.0,
          y: 1.0,
          z: 1.0,
          duration: 0.2,
          ease: 'power2.in',
          onComplete: () => {
            this.buttonAnimating = false;
            if (this.buttonCallback) {
              this.buttonCallback();
            }
          }
        });
      }
    });
  }
  showWinner(winner) {
    let targetPlane = null;
    if (winner === 'O') {
      targetPlane = this.endGameOPlane;
    } else if (winner === 'X') {
      targetPlane = this.endGameXPlane;
    } else {
      return;
    }
    if (!targetPlane) return;
    targetPlane.scale.set(0, 0, 0);
    this.endGameButtonPlane.scale.set(0, 0, 0);
    gsap.to(targetPlane.scale, {
      x: 1.2,
      y: 1.2,
      z: 1.2,
      duration: 0.5,
      ease: 'power3.out'
    });
    gsap.to(this.endGameButtonPlane.scale, {
      x: 1.2,
      y: 1.2,
      z: 1.2,
      duration: 0.5,
      delay: 0.2,
      ease: 'power3.out'
    });
  }
  hideAll() {
    const targets = [
      this.endGameOPlane?.scale,
      this.endGameXPlane?.scale,
      this.endGameButtonPlane?.scale
    ].filter(Boolean);
    if (targets.length === 0) return;
    gsap.to(targets, {
      x: 0,
      y: 0,
      z: 0,
      duration: 0.2,
      ease: 'power3.in'
    });
    if (this.currentText) {
      this.currentText.parent?.remove(this.currentText);
      this.currentText.geometry?.dispose();
      if (Array.isArray(this.currentText.material)) {
        this.currentText.material.forEach((m) => m.dispose?.());
      } else {
        this.currentText.material?.dispose?.();
      }
      this.currentText = null;
    }
  }
}

====== CONTENT OF: tictactoe\src\GameState3D.js ======
export const GRID_SIZE = 3;
export class GameState3D {
  constructor() {
    this.grid = this._createEmptyGrid();
    this.isGameOver = false;
    this.winner = null;       
    this.winningLine = null;  
  }
  _createEmptyGrid() {
    return Array(GRID_SIZE).fill().map(() =>
      Array(GRID_SIZE).fill().map(() =>
        Array(GRID_SIZE).fill(null)
      )
    );
  }
  reset() {
    this.grid = this._createEmptyGrid();
    this.isGameOver = false;
    this.winner = null;
    this.winningLine = null;
  }
  makeMove(x, y, z, player) {
    if (this.isGameOver) {
      return { success: false, winner: this.winner };
    }
    if (this.grid[x][y][z] !== null) {
      return { success: false, winner: this.winner };
    }
    this.grid[x][y][z] = player;
    const result = this._checkWinOrDraw();
    if (result) {
      this.isGameOver = true;
      this.winner = result;
    }
    return { success: true, winner: this.winner };
  }
  getWinningLine() {
    return this.winningLine;
  }
  _checkWinOrDraw() {
    this.winningLine = null;
    const directions = [
      ...[0, 1, 2].flatMap((y) =>
        [0, 1, 2].map((z) => ({ dx: 1, dy: 0, dz: 0, x: 0, y, z }))
      ),
      ...[0, 1, 2].flatMap((x) =>
        [0, 1, 2].map((z) => ({ dx: 0, dy: 1, dz: 0, x, y: 0, z }))
      ),
      ...[0, 1, 2].flatMap((x) =>
        [0, 1, 2].map((y) => ({ dx: 0, dy: 0, dz: 1, x, y, z: 0 }))
      ),
      ...[0, 1, 2].map((z) => ({ dx: 1, dy: 1, dz: 0, x: 0, y: 0, z })),
      ...[0, 1, 2].map((z) => ({ dx: 1, dy: -1, dz: 0, x: 0, y: 2, z })),
      ...[0, 1, 2].map((y) => ({ dx: 1, dy: 0, dz: 1, x: 0, y, z: 0 })),
      ...[0, 1, 2].map((y) => ({ dx: 1, dy: 0, dz: -1, x: 0, y, z: 2 })),
      ...[0, 1, 2].map((x) => ({ dx: 0, dy: 1, dz: 1, x, y: 0, z: 0 })),
      ...[0, 1, 2].map((x) => ({ dx: 0, dy: 1, dz: -1, x, y: 0, z: 2 })),
      { dx: 1, dy: 1, dz: 1, x: 0, y: 0, z: 0 },
      { dx: 1, dy: 1, dz: -1, x: 0, y: 0, z: 2 },
      { dx: 1, dy: -1, dz: 1, x: 0, y: 2, z: 0 },
      { dx: 1, dy: -1, dz: -1, x: 0, y: 2, z: 2 }
    ];
    for (const dir of directions) {
      const line = [];
      const start = { x: dir.x, y: dir.y, z: dir.z };
      let x = dir.x;
      let y = dir.y;
      let z = dir.z;
      for (let i = 0; i < 3; i++) {
        if (x >= 0 && x < 3 && y >= 0 && y < 3 && z >= 0 && z < 3) {
          line.push(this.grid[x][y][z]);
        }
        x += dir.dx;
        y += dir.dy;
        z += dir.dz;
      }
      if (line.length === 3 && line[0] !== null && line.every((v) => v === line[0])) {
        this.winningLine = {
          start,
          end: {
            x: start.x + 2 * dir.dx,
            y: start.y + 2 * dir.dy,
            z: start.z + 2 * dir.dz
          }
        };
        return line[0]; 
      }
    }
    const isFull = this.grid.every((plane) =>
      plane.every((row) => row.every((cell) => cell !== null))
    );
    if (isFull) {
      this.winningLine = null;
      return 'draw';
    }
    return null;
  }
  _countInLine(line, player) {
    const playerCount = line.filter((c) => c === player).length;
    const emptyCount = line.filter((c) => c === null).length;
    const opponentCount = line.filter((c) => c !== null && c !== player).length;
    return { playerCount, emptyCount, opponentCount };
  }
  _getLinesThrough(x, y, z) {
    const lines = [];
    const dirs = [
      { dx: 1, dy: 0, dz: 0 },
      { dx: 0, dy: 1, dz: 0 },
      { dx: 0, dy: 0, dz: 1 },
      { dx: 1, dy: 1, dz: 0 },
      { dx: 1, dy: -1, dz: 0 },
      { dx: 1, dy: 0, dz: 1 },
      { dx: 1, dy: 0, dz: -1 },
      { dx: 0, dy: 1, dz: 1 },
      { dx: 0, dy: 1, dz: -1 },
      { dx: 1, dy: 1, dz: 1 },
      { dx: 1, dy: 1, dz: -1 },
      { dx: 1, dy: -1, dz: 1 },
      { dx: 1, dy: -1, dz: -1 }
    ];
    for (const { dx, dy, dz } of dirs) {
      for (let t = -2; t <= 0; t++) {
        const cells = [];
        let valid = true;
        for (let k = 0; k < 3; k++) {
          const px = x + (t + k) * dx;
          const py = y + (t + k) * dy;
          const pz = z + (t + k) * dz;
          if (px < 0 || px > 2 || py < 0 || py > 2 || pz < 0 || pz > 2) {
            valid = false;
            break;
          }
          cells.push({ x: px, y: py, z: pz });
        }
        if (valid && t <= 0 && t + 2 >= 0) {
          lines.push(cells.map((c) => this.grid[c.x][c.y][c.z]));
        }
      }
    }
    return lines;
  }
  evaluatePosition(x, y, z, player) {
    if (this.grid[x][y][z] !== null) return -1;
    let score = 0;
    const opponent = player === 'X' ? 'O' : 'X';
    const lines = this._getLinesThrough(x, y, z);
    for (const line of lines) {
      const counts = this._countInLine(line, player);
      if (counts.playerCount === 2 && counts.emptyCount === 1) {
        return 1000;
      }
      const oppCounts = this._countInLine(line, opponent);
      if (oppCounts.playerCount === 2 && oppCounts.emptyCount === 1) {
        return 900;
      }
      if (counts.playerCount === 1 && counts.emptyCount === 2) {
        score += 50;
      }
      if (oppCounts.playerCount === 1 && oppCounts.emptyCount === 2) {
        score += 40;
      }
    }
    if (x === 1 && y === 1 && z === 1) {
      score += 100; 
    } else if (
      (x === 1 && y === 1) ||
      (x === 1 && z === 1) ||
      (y === 1 && z === 1)
    ) {
      score += 50; 
    } else if (
      (x === 0 || x === 2) &&
      (y === 0 || y === 2) &&
      (z === 0 || z === 2)
    ) {
      score += 40; 
    } else {
      score += 20; 
    }
    const possibleLines = this._getLinesThrough(x, y, z);
    const potentialWinningLines = possibleLines.filter((line) => {
      const counts = this._countInLine(line, player);
      return counts.playerCount === 0 && counts.emptyCount === 3;
    }).length;
    score += potentialWinningLines * 30;
    return score;
  }
  findBestMove(player) {
    let bestScore = -1;
    let bestMove = null;
    for (let x = 0; x < GRID_SIZE; x++) {
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let z = 0; z < GRID_SIZE; z++) {
          const score = this.evaluatePosition(x, y, z, player);
          if (score > bestScore) {
            bestScore = score;
            bestMove = { x, y, z };
          }
        }
      }
    }
    return bestMove;
  }
}

====== CONTENT OF: tictactoe\src\HandInput.js ======
import * as THREE from 'three';
export class HandInput {
  constructor(
    renderer,
    scene,
    { chairRotationSpeed = 4.0, maxUpDownRotation = Math.PI / 3 } = {}
  ) {
    this.renderer = renderer;
    this.scene = scene;
    this.chairRotationSpeed = chairRotationSpeed;
    this.maxUpDownRotation = maxUpDownRotation;
    this.onPlaceO = null;
    this.onRotate = null;
    this.onButtonHit = null;
    this.buttonPlane = null;
    this.leftHand = this.renderer.xr.getHand(0);
    this.rightHand = this.renderer.xr.getHand(1);
    this.scene.add(this.leftHand);
    this.scene.add(this.rightHand);
    this.leftRotationActive = false;
    this.rightRotationActive = false;
    this.lastLeftX = 0;
    this.lastLeftY = 0;
    this.lastRightX = 0;
    this.lastRightY = 0;
    this._initJointRefs();
  }
  _initJointRefs() {
    const sphereGeo = new THREE.SphereGeometry(0.002, 32, 32);
    const mat = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      opacity: 0,
      transparent: true
    });
    this.lThumbObj = new THREE.Mesh(sphereGeo, mat);
    this.lIndexObj = new THREE.Mesh(sphereGeo, mat.clone());
    this.rThumbObj = new THREE.Mesh(sphereGeo, mat.clone());
    this.rIndexObj = new THREE.Mesh(sphereGeo, mat.clone());
    this.scene.add(
      this.lThumbObj,
      this.lIndexObj,
      this.rThumbObj,
      this.rIndexObj
    );
  }
  setButtonPlane(plane) {
    this.buttonPlane = plane;
  }
  setPlaceOCallback(cb) {
    this.onPlaceO = cb;
  }
  setRotateCallback(cb) {
    this.onRotate = cb;
  }
  setButtonHitCallback(cb) {
    this.onButtonHit = cb;
  }
  update() {
    this._updateHands();
    this._processPinches();
    this._processButtonHit();
  }
  _updateHands() {
    const lh = this.leftHand;
    const rh = this.rightHand;
    if (lh?.joints?.['thumb-tip']) {
      this.lThumbObj.position.copy(lh.joints['thumb-tip'].position);
    }
    if (lh?.joints?.['index-finger-tip']) {
      this.lIndexObj.position.copy(lh.joints['index-finger-tip'].position);
    }
    if (rh?.joints?.['thumb-tip']) {
      this.rThumbObj.position.copy(rh.joints['thumb-tip'].position);
    }
    if (rh?.joints?.['index-finger-tip']) {
      this.rIndexObj.position.copy(rh.joints['index-finger-tip'].position);
    }
  }
  _processPinches() {
    this._handleHandPinch('left', this.lThumbObj, this.lIndexObj);
    this._handleHandPinch('right', this.rThumbObj, this.rIndexObj);
  }
  _handleHandPinch(handName, thumbObj, indexObj) {
    const dist = thumbObj.position.distanceTo(indexObj.position);
    const isPinching = dist < 0.02;
    if (isPinching) {
      if (handName === 'left') {
        if (!this.leftRotationActive) {
          this.leftRotationActive = true;
          this.lastLeftX = thumbObj.position.x;
          this.lastLeftY = thumbObj.position.y;
          this.onPlaceO?.({
            hand: handName,
            thumbWorldPos: thumbObj.position.clone()
          });
        } else {
          const dx = thumbObj.position.x - this.lastLeftX;
          const dy = thumbObj.position.y - this.lastLeftY;
          this._emitRotate(dx, dy);
          this.lastLeftX = thumbObj.position.x;
          this.lastLeftY = thumbObj.position.y;
        }
      } else {
        if (!this.rightRotationActive) {
          this.rightRotationActive = true;
          this.lastRightX = thumbObj.position.x;
          this.lastRightY = thumbObj.position.y;
          this.onPlaceO?.({
            hand: handName,
            thumbWorldPos: thumbObj.position.clone()
          });
        } else {
          const dx = thumbObj.position.x - this.lastRightX;
          const dy = thumbObj.position.y - this.lastRightY;
          this._emitRotate(dx, dy);
          this.lastRightX = thumbObj.position.x;
          this.lastRightY = thumbObj.position.y;
        }
      }
    } else {
      if (handName === 'left') {
        this.leftRotationActive = false;
      } else {
        this.rightRotationActive = false;
      }
    }
  }
  _emitRotate(deltaX, deltaY) {
    if (Math.abs(deltaX) < 0.001 && Math.abs(deltaY) < 0.001) return;
    this.onRotate?.({
      deltaX,
      deltaY,
      speed: this.chairRotationSpeed,
      maxUpDownRotation: this.maxUpDownRotation
    });
  }
  _processButtonHit() {
    if (!this.buttonPlane || !this.onButtonHit) return;
    const lh = this.leftHand;
    const rh = this.rightHand;
    const check = (hand) => {
      if (!hand?.joints?.['index-finger-tip']) return;
      const p = new THREE.Vector3().copy(
        hand.joints['index-finger-tip'].position
      );
      if (this._checkPlaneIntersection(p, this.buttonPlane)) {
        this.onButtonHit();
      }
    };
    check(lh);
    check(rh);
  }
  _checkPlaneIntersection(point, plane) {
    if (!plane.visible || plane.scale.x === 0) return false;
    const w = plane.geometry.parameters.width;
    const h = plane.geometry.parameters.height;
    const halfWidth = w * 0.5;
    const halfHeight = h * 0.5;
    const localPoint = point.clone();
    plane.worldToLocal(localPoint);
    return (
      localPoint.x >= -halfWidth &&
      localPoint.x <= halfWidth &&
      localPoint.y >= -halfHeight &&
      localPoint.y <= halfHeight &&
      Math.abs(localPoint.z) < 0.02
    );
  }
}

====== CONTENT OF: tictactoe\src\main.js ======
import * as THREE from 'three';
import { XRButton } from 'three/addons/webxr/XRButton.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import gsap from 'gsap';
import { GameState3D } from './GameState3D.js';
import { BoardView } from './BoardView.js';
import { EndGameUI } from './EndGameUI.js';
import { HandInput } from './HandInput.js';
gsap.ticker.lagSmoothing(0);
gsap.ticker.fps(60);
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(
  50,
  window.innerWidth / window.innerHeight,
  0.1,
  50
);
camera.position.set(0, 1.6, 3);
scene.add(camera);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
const xrButton = XRButton.createButton(renderer, {
  optionalFeatures: ['hand-tracking'],
});
xrButton.style.display = 'none';
xrButton.style.opacity = '0';
xrButton.style.visibility = 'hidden';
xrButton.style.pointerEvents = 'none';
xrButton.style.position = 'absolute';
xrButton.style.width = '0';
xrButton.style.height = '0';
xrButton.style.padding = '0';
xrButton.style.margin = '0';
xrButton.style.border = 'none';
xrButton.style.overflow = 'hidden';
document.body.appendChild(xrButton);
document.body.style.cursor = 'pointer';
document.body.addEventListener('click', () => {
  xrButton.click();
});
document.body.addEventListener('mouseenter', () => {
  document.body.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
});
document.body.addEventListener('mouseleave', () => {
  document.body.style.backgroundColor = '';
});
const ambientLight = new THREE.AmbientLight(0xb4c8ff, 1.4);
scene.add(ambientLight);
const keyLight = new THREE.DirectionalLight(0xfff0dd, 2.8);
keyLight.position.set(2, 4, 2);
scene.add(keyLight);
const fillLight = new THREE.DirectionalLight(0xb4e5ff, 1.8);
fillLight.position.set(-3, 2, 1);
scene.add(fillLight);
const rimLight = new THREE.DirectionalLight(0x8eb8ff, 1.2);
rimLight.position.set(-1, 3, -2);
scene.add(rimLight);
const groundLight = new THREE.DirectionalLight(0xffffff, 0.4);
groundLight.position.set(0, -3, 0);
scene.add(groundLight);
const orangeMaterial = new THREE.MeshPhysicalMaterial({
  color: 0xff9737,
  metalness: 0.25,
  roughness: 0.4,
  sheen: 0.6,
  sheenRoughness: 0.6,
  clearcoat: 0.45,
  clearcoatRoughness: 0.45,
  emissive: 0xff9737,
  emissiveIntensity: 0.25,
  envMapIntensity: 1.3,
});
const lightBlueMaterial = new THREE.MeshPhysicalMaterial({
  color: 0x60aeff,
  metalness: 0.25,
  roughness: 0.4,
  emissive: 0x60aeff,
  emissiveIntensity: 0.25,
  clearcoat: 0.45,
  clearcoatRoughness: 0.45,
  envMapIntensity: 1.3,
});
const gltfLoader = new GLTFLoader();
function loadGLTF(url) {
  return new Promise((resolve, reject) => {
    gltfLoader.load(
      url,
      (gltf) => resolve(gltf),
      undefined,
      (error) => reject(error)
    );
  });
}
let xrSessionStartTime = null;
let compositionPositioned = false;
let boardView = null; 
renderer.xr.addEventListener('sessionstart', () => {
  xrSessionStartTime = Date.now();
  compositionPositioned = false;
  document.body.classList.add('xr-presenting');
});
renderer.xr.addEventListener('sessionend', () => {
  xrSessionStartTime = null;
  compositionPositioned = false;
  document.body.classList.remove('xr-presenting');
});
function positionCompositionAtHeadHeight() {
  if (!xrSessionStartTime || compositionPositioned || !boardView?.baseComposition) return;
  const elapsed = Date.now() - xrSessionStartTime;
  if (elapsed < 1000) return; 
  const headHeight = camera.position.y;
  const headDistance = camera.position.z;
  boardView.baseComposition.position.set(0, headHeight, headDistance - 1.0);
  compositionPositioned = true;
}
const clock = new THREE.Clock();
let gameState = null;
let endGameUI = null;
let handInput = null;
const MOVE_COOLDOWN = 800;
let lastMoveTime = 0;
Promise.all([
  loadGLTF('/static/x.glb'),
  loadGLTF('/static/o.glb'),
]).then(([xGltf, oGltf]) => {
  const xModelTemplate = xGltf.scene;
  xModelTemplate.traverse((child) => {
    if (child.isMesh) {
      child.material = lightBlueMaterial;
    }
  });
  const oModelTemplate = oGltf.scene;
  oModelTemplate.traverse((child) => {
    if (child.isMesh) {
      child.material = orangeMaterial;
    }
  });
  startApp(xModelTemplate, oModelTemplate).catch((err) => {
    console.error('Error starting app:', err);
  });
}).catch((err) => {
  console.error('Error loading X/O models:', err);
});
async function startApp(xModelTemplate, oModelTemplate) {
  gameState = new GameState3D();
  boardView = new BoardView(scene, {
    orangeMaterial,
    lightBlueMaterial,
    xModelTemplate,
    oModelTemplate,
  });
  await boardView.loadGridModel('/static/tictactoe.glb');
  endGameUI = new EndGameUI(boardView.baseComposition, {
    xModelTemplate,
    orangeMaterial,
    lightBlueMaterial,
  });
  handInput = new HandInput(renderer, scene, {
    chairRotationSpeed: 4.0,
    maxUpDownRotation: Math.PI / 3,
  });
  handInput.setButtonPlane(endGameUI.getButtonPlane());
  endGameUI.onButtonPress(() => {
    resetGame();
  });
  handInput.setButtonHitCallback(() => {
    endGameUI.triggerButtonPress();
  });
  handInput.setPlaceOCallback(({ hand, thumbWorldPos }) => {
    if (!boardView.baseGrid || gameState.isGameOver) return;
    const now = Date.now();
    if (now - lastMoveTime < MOVE_COOLDOWN) return;
    const nearestSphere = boardView.findNearestSphere(thumbWorldPos);
    if (!nearestSphere) return;
    if (!boardView.isSphereFree(nearestSphere.uuid)) return;
    const coords = boardView.getGridCoordsFromSphere(nearestSphere.uuid);
    if (!coords) return;
    const moveResult = gameState.makeMove(coords.x, coords.y, coords.z, 'O');
    if (!moveResult.success) return;
    const worldPos = new THREE.Vector3();
    nearestSphere.getWorldPosition(worldPos);
    const localPos = boardView.worldToLocalOnGrid(worldPos);
    boardView.spawnO(localPos);
    nearestSphere.visible = false;
    boardView.markSphereUsed(nearestSphere.uuid, 'O');
    lastMoveTime = now;
    if (gameState.winner) {
        if (gameState.winner !== 'draw') {
          endGameUI.showWinner(gameState.winner);
          const line = gameState.getWinningLine();
          if (line) {
            boardView.showWinningLine(line.start, line.end);
          }
        }
        return;
    }
    setTimeout(() => {
      if (gameState.isGameOver) return;
      const best = gameState.findBestMove('X');
      if (!best) return;
      const sphere = boardView.findSphereByGridPos(best.x, best.y, best.z);
      if (!sphere || !boardView.isSphereFree(sphere.uuid)) return;
      const compResult = gameState.makeMove(best.x, best.y, best.z, 'X');
      if (!compResult.success) return;
      const worldPos2 = new THREE.Vector3();
      sphere.getWorldPosition(worldPos2);
      const localPos2 = boardView.worldToLocalOnGrid(worldPos2);
      boardView.spawnX(localPos2);
      sphere.visible = false;
      boardView.markSphereUsed(sphere.uuid, 'X');
      if (gameState.winner && gameState.winner !== 'draw') {
        endGameUI.showWinner(gameState.winner);
        const line = gameState.getWinningLine();
        if (line) {
          boardView.showWinningLine(line.start, line.end);
        }
      }
    }, 500);
  });
  handInput.setRotateCallback(({ deltaX, deltaY, speed, maxUpDownRotation }) => {
    if (!boardView.baseGrid) return;
    boardView.baseGrid.rotation.y += deltaX * speed;
    const newX = boardView.baseGrid.rotation.x - deltaY * speed;
    const clampedX = Math.max(-maxUpDownRotation, Math.min(maxUpDownRotation, newX));
    boardView.baseGrid.rotation.x = clampedX;
  });
  const clock = new THREE.Clock();
  renderer.setAnimationLoop(() => {
    const delta = clock.getDelta();
    gsap.ticker.tick(delta);
    handInput.update(delta);
    positionCompositionAtHeadHeight();
    renderer.render(scene, camera);
  });
}
function resetGame() {
  gameState.reset();
  lastMoveTime = 0;
  boardView.resetVisuals();
  endGameUI.hideAll();
}
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

====== CONTENT OF: tictactoe\src\style.css ======
.webgl
{
    position: fixed;
    top: 0;
    left: 0
}
/* Hide default WebXR button */
#VRButton {
    display: none !important;
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    position: absolute !important;
    width: 0 !important;
    height: 0 !important;
    padding: 0 !important;
    margin: 0 !important;
    border: none !important;
    overflow: hidden !important;
}
html, 
body 
{
    overflow: hidden;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}
/* Add a click instruction overlay */
body::before {
    content: "Start WebXR";
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #ffff00;
    color: #000;
    padding: 20px 40px;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: 18px;
    font-weight: bold;
    z-index: 1000;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
/* Hide instruction when in XR */
body.xr-presenting::before {
    opacity: 0;
}

